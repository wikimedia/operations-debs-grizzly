From 0d846d68a25e4770875dc165623e92db6f2a9ee9 Mon Sep 17 00:00:00 2001
From: Filippo Giunchedi <filippo@debian.org>
Date: Fri, 12 Mar 2021 10:16:59 +0100
Subject: [PATCH 3/3] vendor clix

---
 vendor/github.com/go-clix/cli/LICENSE    | 201 +++++++++++++++++++++
 vendor/github.com/go-clix/cli/README.md  | 211 +++++++++++++++++++++++
 vendor/github.com/go-clix/cli/args.go    | 140 +++++++++++++++
 vendor/github.com/go-clix/cli/childs.go  |  65 +++++++
 vendor/github.com/go-clix/cli/command.go | 146 ++++++++++++++++
 vendor/github.com/go-clix/cli/flags.go   |  74 ++++++++
 vendor/github.com/go-clix/cli/go.mod     |   9 +
 vendor/github.com/go-clix/cli/go.sum     |  19 ++
 vendor/github.com/go-clix/cli/help.go    | 132 ++++++++++++++
 vendor/github.com/go-clix/cli/predict.go |  87 ++++++++++
 10 files changed, 1084 insertions(+)
 create mode 100644 vendor/github.com/go-clix/cli/LICENSE
 create mode 100644 vendor/github.com/go-clix/cli/README.md
 create mode 100644 vendor/github.com/go-clix/cli/args.go
 create mode 100644 vendor/github.com/go-clix/cli/childs.go
 create mode 100644 vendor/github.com/go-clix/cli/command.go
 create mode 100644 vendor/github.com/go-clix/cli/flags.go
 create mode 100644 vendor/github.com/go-clix/cli/go.mod
 create mode 100644 vendor/github.com/go-clix/cli/go.sum
 create mode 100644 vendor/github.com/go-clix/cli/help.go
 create mode 100644 vendor/github.com/go-clix/cli/predict.go

diff --git a/vendor/github.com/go-clix/cli/LICENSE b/vendor/github.com/go-clix/cli/LICENSE
new file mode 100644
index 0000000..ef02dcc
--- /dev/null
+++ b/vendor/github.com/go-clix/cli/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2020 go-clix authors, sh0rez
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/vendor/github.com/go-clix/cli/README.md b/vendor/github.com/go-clix/cli/README.md
new file mode 100644
index 0000000..52e3263
--- /dev/null
+++ b/vendor/github.com/go-clix/cli/README.md
@@ -0,0 +1,211 @@
+# `go-clix`
+
+Cli-X is a command line library for Go, inspired by
+[`spf13/cobra`](https://github.com/spf13/cobra).
+
+- :package: **`struct` based API**: Similar to `cobra`, `clix` features a `struct` based
+  API for easy composition and discovery of available options.
+- :children_crossing: [**Subcommands**](#subcommands): `clix.Command` can be nested for a `git`
+  like experience.
+- :pushpin: [**Flags**](#flags): Every command has it's own set of flags. POSIX compliant
+  using `spf13/pflag`.
+- :busts_in_silhouette: [**Aliases**](#aliases): Commands can have multiple names, so
+  breaking changes can easily be mitigated.
+- :dart: **Go based completion**: `<TAB>` completion is supported for `bash`, `zsh` and
+  `fish`. But you can generate suggestions using [**Go code**](#completion)!
+
+## Getting started
+
+Add the library to your project:
+
+```bash
+$ go get github.com/go-clix/cli
+```
+
+Then set up your root command:
+
+```go
+package main
+
+import (
+    "fmt"
+    "github.com/go-clix/cli"
+)
+
+func main() {
+    // create the root command
+    rootCmd := clix.Command{
+        Use: "greet",
+        Short: "print a message",
+        Run: func(cmd *clix.Command, args []string) error {
+            fmt.Println("Hello from Cli-X!")
+        }
+    }
+
+    // run and check for errors
+    if err := rootCmd.Execute(); err != nil {
+        fmt.Println(err)
+        os.Exit(1)
+    }
+}
+```
+
+## Subcommands
+
+Every command may have children:
+
+```go
+// use a func to return a Command instead of
+// a global variable and `init()`
+func applyCmd() *clix.Command {
+    cmd := &clix.Command{
+        Use: "apply",
+        Short: "apply the changes"
+    }
+
+    cmd.Run = func(cmd *clix.Command, args []string) error {
+        fmt.Println("applied", args[0])
+    }
+}
+
+func main() {
+    rootCmd := &clix.Comand{
+        Use: "kubectl",
+        Short: "Kubernetes management tool",
+    }
+
+    // add the child command
+    rootCmd.AddChildren(
+       applyCmd(),
+    )
+
+    // run and check for errors
+    if err := rootCmd.Execute(); err != nil {
+        fmt.Println(err)
+        os.Exit(1)
+    }
+}
+```
+
+> **Note:** Do not use the `init()` function for setting up your commands.
+> Create constructors as shown above!
+
+## Flags
+
+A `pflag.FlagSet` can be accessed per command using `*Command.Flags()`:
+
+```go
+func applyCmd() *clix.Command {
+    cmd := &clix.Command{
+        Use: "apply",
+        Short: "apply the changes"
+    }
+
+    force := cmd.Flags().BoolP("force", "f", false, "skip checks")
+
+    cmd.Run = func(cmd *clix.Command, args []string) error {
+        fmt.Println("applied", args[0])
+        if *force {
+            fmt.Println("The force was with us.")
+        }
+    }
+}
+```
+
+## Aliases
+
+To make the `apply` subcommand also available as `make` and `do`:
+
+```go
+func applyCmd() *clix.Command {
+    cmd := &clix.Command{
+        Use: "apply",
+        Aliases: []string{"make", "do"},
+        Short: "apply the changes"
+    }
+}
+```
+
+Keep in mind that in `--help` outputs the command will still be called `apply`.
+
+## Completion
+
+Cli-X has a very powerful cli completion system, based on
+[`posener/complete`](https://github.com/posener/complete).
+
+It is powerful, because suggestions come directly from the Go application, not
+from a `bash` script or similar.
+
+Command and Flag names are automatically suggested, custom suggestions can be
+implemented for [positional arguments](#positional-arguments) and [flag
+values](#flag-values):
+
+### Flag Values
+
+Custom suggestions for flag values can be set up using `Command.Predictors`.
+
+To do so, you need to add a `complete.Predictor` for that flag. Cli-X has a
+number of predefined ones:
+
+- `PredictAny()`: Predicts available files and directories, like `bash` does when
+  having no better idea
+- `PredictNone()`: Predicts literally nothing. No suggestions will be shown.
+- `PredictSet(...string)`: Suggests from a predefined slice of options
+
+If that's not sufficient, use `PredictFunc(func(complete.Args) []string)` to
+create your own.
+
+```go
+import (
+    "github.com/posener/complete"
+    "github.com/go-clix/cli"
+)
+
+func logsCmd() *clix.Command {
+    cmd := &clix.Command{
+        Use: "logs",
+        Short: "show logs of a pod",
+        Predictors: map[string]complete.Predictor{
+            "output": clix.PredictSet("lines", "json", "logfmt"),
+        },
+    }
+
+    output := cmd.Flags().StringP("output", "o", "lines", "one of [lines, json, logfmt]")
+}
+```
+
+### Positional Arguments
+
+For positional arguments, Cli-X uses a slightly different `interface`, to allow
+validation as well:
+
+```go
+interface {
+    Validate(args []string) error
+    Predict(Args) []string
+}
+```
+
+Predefined options are also available:
+
+- `ArgsAny()`: accepts any number args, predicts files and directories
+- `ArgsExact(n)`: accepts _exactly_ `n` arguments. Predicts files and directories.
+- `ArgsNone()`: accepts _no_ args and predicts nothing.
+- `ArgsSet(...string)`: Accepts _one_ argument, which MUST be included in the
+  given set. Predicts the values from the set.
+
+```go
+import (
+    "github.com/posener/complete"
+    "github.com/go-clix/cli"
+)
+
+func applyCmd() *clix.Command {
+    cmd := &clix.Command{
+        Use: "logs",
+        Short: "show logs of a pod",
+        // we expect one argument which can be anything
+        Args: clix.ArgsExact(1),
+    }
+}
+```
diff --git a/vendor/github.com/go-clix/cli/args.go b/vendor/github.com/go-clix/cli/args.go
new file mode 100644
index 0000000..bdcc1fa
--- /dev/null
+++ b/vendor/github.com/go-clix/cli/args.go
@@ -0,0 +1,140 @@
+package cli
+
+import (
+	"fmt"
+
+	"github.com/posener/complete"
+)
+
+// Arguments is used to validate and complete positional arguments.
+// Use `Args()` to create an instance from functions.
+type Arguments interface {
+	Validator
+	complete.Predictor
+}
+
+// Validator checks that arguments have the expected form
+type Validator interface {
+	// Validate receives the arguments of the command (without flags) and shall
+	// return an error if they are unexpected.
+	Validate(args []string) error
+}
+
+// Args bundles user-supplied implementations of the respective interfaces into
+// an Arguments implementation.
+type Args struct {
+	Validator
+	complete.Predictor
+}
+
+// ValidateFunc allows to use an ordinary func as an Validator
+type ValidateFunc func(args []string) error
+
+// Validate wrap the underlying function
+func (v ValidateFunc) Validate(args []string) error {
+	return v(args)
+}
+
+// PredictFunc allows to use an ordinary func as an Predictor
+type PredictFunc = complete.PredictFunc
+
+// ---
+// Common Argument implementations
+// ---
+
+// No Arguments
+
+// ArgsNone checks that no arguments were given, and disables predictions.
+func ArgsNone() Arguments {
+	return Args{
+		Validator: ValidateNone(),
+		Predictor: PredictNone(),
+	}
+}
+
+// ValidateNone checks for no arguments at all
+func ValidateNone() ValidateFunc {
+	return ValidateExact(0)
+}
+
+// PredictNone predicts exactly nothing
+func PredictNone() complete.Predictor {
+	return PredictFunc(func(args complete.Args) []string {
+		return nil
+	})
+}
+
+// Exact arguments
+
+// ArgsExact checks for exactly n arguments, predicting anything
+func ArgsExact(n int) Arguments {
+	return Args{
+		Validator: ValidateExact(n),
+		Predictor: PredictAny(),
+	}
+}
+
+// ValidateExact checks that exactly n arguments were given
+func ValidateExact(n int) ValidateFunc {
+	return func(args []string) error {
+		if len(args) != n {
+			return fmt.Errorf("accepts %v arg, received %v", n, len(args))
+		}
+		return nil
+	}
+}
+
+// Any arguments
+
+// ArgsAny allows any number of arguments with any value
+func ArgsAny() Arguments {
+	return Args{
+		Validator: ValidateAny(),
+		Predictor: PredictAny(),
+	}
+}
+
+// PredictAny predicts any files/directories
+func PredictAny() complete.Predictor {
+	return complete.PredictFiles("*")
+}
+
+// ValidateAny always approves
+func ValidateAny() ValidateFunc {
+	return func(args []string) error {
+		return nil
+	}
+}
+
+// Predefined arguments
+
+// ArgsSet check the given argument is in the predefined set of options. Only
+// these options are predicted. Only a single argument is assumed.
+func ArgsSet(set ...string) Arguments {
+	return Args{
+		Validator: ValidateSet(set...),
+		Predictor: PredictSet(set...),
+	}
+}
+
+// PredictSet predicts the values from the given set
+func PredictSet(set ...string) complete.Predictor {
+	return complete.PredictSet(set...)
+}
+
+// ValidateSet checks that the given single argument is part of the set.
+func ValidateSet(set ...string) ValidateFunc {
+	return func(args []string) error {
+		if err := ValidateExact(1)(args); err != nil {
+			return err
+		}
+
+		for _, s := range set {
+			if args[0] == s {
+				return nil
+			}
+		}
+
+		return fmt.Errorf("only accepts %v", set)
+	}
+}
diff --git a/vendor/github.com/go-clix/cli/childs.go b/vendor/github.com/go-clix/cli/childs.go
new file mode 100644
index 0000000..f028f80
--- /dev/null
+++ b/vendor/github.com/go-clix/cli/childs.go
@@ -0,0 +1,65 @@
+package cli
+
+import "fmt"
+
+// AddCommand adds the supplied commands as subcommands.
+// This command is set as the parent of the new children.
+func (c *Command) AddCommand(childs ...*Command) {
+	for _, child := range childs {
+		child.parentPtr = c
+		c.children = append(c.children, child)
+	}
+}
+
+// findTarget finds the specified (sub)command based on the args
+func findTarget(c *Command, args []string) (*Command, []string, error) {
+	argsWOflags := stripFlags(args, c)
+	if len(argsWOflags) == 0 {
+		return c, args, nil
+	}
+	nextSubCmd := argsWOflags[0]
+
+	cmd, ok := c.child(nextSubCmd)
+	switch {
+	case !ok && c.children != nil:
+		return nil, nil, c.help(fmt.Errorf("unknown subcommand `%s`", nextSubCmd))
+	case cmd != nil:
+		return findTarget(cmd, argsMinusFirstX(args, nextSubCmd))
+	}
+	return c, args, nil
+}
+
+func (c *Command) child(name string) (*Command, bool) {
+	for _, child := range c.children {
+		if child.Name() == name {
+			return child, true
+		}
+		if child.hasAlias(name) {
+			return child, true
+		}
+	}
+	return nil, false
+}
+
+func (c *Command) hasAlias(name string) bool {
+	for _, a := range c.Aliases {
+		if name == a {
+			return true
+		}
+	}
+	return false
+}
+
+// argsMinusFirstX removes only the first x from args.  Otherwise, commands that look like
+// openshift admin policy add-role-to-user admin my-user, lose the admin argument (arg[4]).
+func argsMinusFirstX(args []string, x string) []string {
+	for i, y := range args {
+		if x == y {
+			ret := []string{}
+			ret = append(ret, args[:i]...)
+			ret = append(ret, args[i+1:]...)
+			return ret
+		}
+	}
+	return args
+}
diff --git a/vendor/github.com/go-clix/cli/command.go b/vendor/github.com/go-clix/cli/command.go
new file mode 100644
index 0000000..c304edc
--- /dev/null
+++ b/vendor/github.com/go-clix/cli/command.go
@@ -0,0 +1,146 @@
+package cli
+
+import (
+	"fmt"
+	"log"
+	"os"
+	"strings"
+
+	"github.com/posener/complete"
+	"github.com/spf13/pflag"
+)
+
+// Command represents a (sub)command of the application. Either `Run()` must be
+// defined, or subcommands added using `AddCommand()`. These are also mutually
+// exclusive.
+type Command struct {
+	// Usage line. First word must be the command name, everything else is
+	// displayed as-is.
+	Use string
+	// Aliases define alternative names for a command
+	Aliases []string
+
+	// Short help text, used for overviews
+	Short string
+	// Long help text, used for full help pages. `Short` is used as a fallback
+	// if unset.
+	Long string
+
+	// Version of the application. Only used on the root command
+	Version string
+
+	// Run is the action that is run when this command is invoked.
+	// The error is returned as-is from `Execute()`.
+	Run func(cmd *Command, args []string) error
+
+	// Validation + Completion
+	//
+	// Predict contains Predictors for flags. Defaults to
+	// `complete.PredictSomething` if unset.
+	// Use the flags name (not shorthand) as the key.
+	Predictors map[string]complete.Predictor
+	// Args is used to validate and complete positional arguments
+	Args Arguments
+
+	// internal fields
+	children  []*Command
+	flags     *pflag.FlagSet
+	parentPtr *Command
+}
+
+// Execute runs the application. It should be run on the most outer level
+// command.
+// The error return value is used for both, application errors but also help texts.
+func (c *Command) Execute() error {
+	// Execute must be called on the top level command
+	if c.parentPtr != nil {
+		return c.parentPtr.Execute()
+	}
+
+	// add subcommand for install CLI completions
+	c.AddCommand(completionCmd(c.Use))
+
+	// exit if in bash completion context
+	if predict(c) {
+		return nil
+	}
+
+	// find the correct (sub)command
+	command, args, err := findTarget(c, os.Args[1:])
+	if err != nil {
+		return err
+	}
+
+	return command.execute(args)
+}
+
+func (c *Command) execute(args []string) error {
+	// add help flag
+	var showHelp *bool
+	if c.Flags().Lookup("help") == nil {
+		showHelp = initHelpFlag(c)
+	}
+
+	// add version flag, but only to the root command.
+	var showVersion *bool
+	if c.parentPtr == nil && c.Version != "" {
+		showVersion = c.Flags().Bool("version", false, fmt.Sprintf("version for %s", c.Use))
+	}
+
+	// parse flags
+	if err := c.Flags().Parse(args); err != nil {
+		return c.help(err)
+	}
+
+	// show version if requested.
+	if showVersion != nil && *showVersion {
+		log.Printf("%s version %s", c.Use, c.Version)
+		return nil
+	}
+
+	// show help if requested or missing `Run()`
+	switch {
+	case showHelp != nil && *showHelp:
+		fallthrough
+	case c.Run == nil:
+		return helpErr(c)
+	}
+
+	// validate args
+	if c.Args == nil {
+		c.Args = ArgsAny()
+	}
+	if err := c.Args.Validate(c.Flags().Args()); err != nil {
+		return c.help(err)
+	}
+
+	// run!
+	return c.Run(c, c.Flags().Args())
+}
+
+func initHelpFlag(c *Command) *bool {
+	return c.Flags().BoolP("help", "h", false, "help for "+c.Name())
+}
+
+func helpErr(c *Command) error {
+	help := c.Short
+	if c.Long != "" {
+		help = c.Long
+	}
+
+	return fmt.Errorf("%s\n\n%s", help, c.Usage())
+}
+
+// Name of this command. The first segment of the `Use` field.
+func (c *Command) Name() string {
+	return strings.Split(c.Use, " ")[0]
+}
+
+// Usage string
+func (c *Command) Usage() string {
+	return c.helpable().Generate()
+}
+
+func (c *Command) helpable() *helpable {
+	return &helpable{*c}
+}
diff --git a/vendor/github.com/go-clix/cli/flags.go b/vendor/github.com/go-clix/cli/flags.go
new file mode 100644
index 0000000..f14f162
--- /dev/null
+++ b/vendor/github.com/go-clix/cli/flags.go
@@ -0,0 +1,74 @@
+package cli
+
+import (
+	"strings"
+
+	"github.com/spf13/pflag"
+)
+
+// Flags returns the `*pflag.FlagSet` of this command
+func (c *Command) Flags() *pflag.FlagSet {
+	if c.flags == nil {
+		c.flags = pflag.NewFlagSet(c.Name(), pflag.ContinueOnError)
+	}
+	return c.flags
+}
+
+// stripFlags removes flags from the argument line, leaving only subcommands and
+// positional arguments.
+func stripFlags(args []string, c *Command) []string {
+	if len(args) == 0 {
+		return args
+	}
+
+	commands := []string{}
+	flags := c.Flags()
+
+Loop:
+	for len(args) > 0 {
+		s := args[0]
+		args = args[1:]
+		switch {
+		case s == "--":
+			// "--" terminates the flags
+			break Loop
+		case strings.HasPrefix(s, "--") && !strings.Contains(s, "=") && !hasNoOptDefVal(s[2:], flags):
+			// If '--flag arg' then
+			// delete arg from args.
+			fallthrough // (do the same as below)
+		case strings.HasPrefix(s, "-") && !strings.Contains(s, "=") && len(s) == 2 && !shortHasNoOptDefVal(s[1:], flags):
+			// If '-f arg' then
+			// delete 'arg' from args or break the loop if len(args) <= 1.
+			if len(args) <= 1 {
+				break Loop
+			} else {
+				args = args[1:]
+				continue
+			}
+		case s != "" && !strings.HasPrefix(s, "-"):
+			commands = append(commands, s)
+		}
+	}
+
+	return commands
+}
+
+func hasNoOptDefVal(name string, fs *pflag.FlagSet) bool {
+	flag := fs.Lookup(name)
+	if flag == nil {
+		return false
+	}
+	return flag.NoOptDefVal != ""
+}
+
+func shortHasNoOptDefVal(name string, fs *pflag.FlagSet) bool {
+	if len(name) == 0 {
+		return false
+	}
+
+	flag := fs.ShorthandLookup(name[:1])
+	if flag == nil {
+		return false
+	}
+	return flag.NoOptDefVal != ""
+}
diff --git a/vendor/github.com/go-clix/cli/go.mod b/vendor/github.com/go-clix/cli/go.mod
new file mode 100644
index 0000000..7643fcf
--- /dev/null
+++ b/vendor/github.com/go-clix/cli/go.mod
@@ -0,0 +1,9 @@
+module github.com/go-clix/cli
+
+go 1.14
+
+require (
+	github.com/posener/complete v1.2.3
+	github.com/spf13/pflag v1.0.5
+	github.com/stretchr/testify v1.4.0
+)
diff --git a/vendor/github.com/go-clix/cli/go.sum b/vendor/github.com/go-clix/cli/go.sum
new file mode 100644
index 0000000..2330fd9
--- /dev/null
+++ b/vendor/github.com/go-clix/cli/go.sum
@@ -0,0 +1,19 @@
+github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=
+github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
+github.com/hashicorp/errwrap v1.0.0 h1:hLrqtEDnRye3+sgx6z4qVLNuviH3MR5aQ0ykNJa/UYA=
+github.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=
+github.com/hashicorp/go-multierror v1.0.0 h1:iVjPR7a6H0tWELX5NxNe7bYopibicUzc7uPribsnS6o=
+github.com/hashicorp/go-multierror v1.0.0/go.mod h1:dHtQlpGsu+cZNNAkkCN/P3hoUDHhCYQXV3UM06sGGrk=
+github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
+github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
+github.com/posener/complete v1.2.3 h1:NP0eAhjcjImqslEwo/1hq7gpajME0fTLTezBKDqfXqo=
+github.com/posener/complete v1.2.3/go.mod h1:WZIdtGGp+qx0sLrYKtIRAruyNpv6hFCicSgv7Sy7s/s=
+github.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=
+github.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
+github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
+github.com/stretchr/testify v1.4.0 h1:2E4SXV/wtOkTonXsotYi4li6zVWxYlZuYNCXe9XRJyk=
+github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
+gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
+gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
+gopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=
+gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
diff --git a/vendor/github.com/go-clix/cli/help.go b/vendor/github.com/go-clix/cli/help.go
new file mode 100644
index 0000000..95baaef
--- /dev/null
+++ b/vendor/github.com/go-clix/cli/help.go
@@ -0,0 +1,132 @@
+package cli
+
+import (
+	"bytes"
+	"fmt"
+	"log"
+	"regexp"
+	"strings"
+	"text/template"
+	"unicode"
+)
+
+func (c *Command) help(reason error) error {
+	if c.Flags().Lookup("help") == nil {
+		_ = initHelpFlag(c)
+	}
+
+	return ErrHelp{
+		Reason: reason,
+		usage:  c.Usage(),
+	}
+}
+
+// ErrHelp wraps an actual error, showing the usage of the command afterwards
+type ErrHelp struct {
+	Reason error
+	usage  string
+}
+
+func (e ErrHelp) Error() string {
+	return fmt.Sprintf("Error: %s\n\n%s", e.Reason.Error(), e.usage)
+}
+
+// helpable is a internal wrapper type of Command that defines functions
+// required to generate the help output using a text/template.
+type helpable struct {
+	Command
+}
+
+func (h *helpable) Generate() string {
+	tmpl := template.New("")
+
+	tmpl = tmpl.Funcs(template.FuncMap{
+		"trimRightSpace": func(s string) string {
+			return strings.TrimRightFunc(s, unicode.IsSpace)
+		},
+		"rpad": func(s string, padding int) string {
+			template := fmt.Sprintf("%%-%ds", padding)
+			return fmt.Sprintf(template, s)
+		},
+	})
+
+	tmpl = template.Must(tmpl.Parse(`
+Usage:
+{{- if .HasChildren }}
+  {{.CommandPath}} [command]
+{{ else }}
+  {{ .Use }}
+{{ end }}
+
+{{if .HasChildren }}
+Available Commands:
+{{- range .Children }}
+  {{rpad .Name .CommandPadding }} {{.Short}}
+{{- end}}
+{{- end}}
+
+{{if .Flags }}
+Flags:
+{{.Flags.FlagUsages}}
+{{ end}}
+
+{{ if .HasChildren }}
+Use "{{.CommandPath}} [command] --help" for more information about a command.
+{{ end}}
+`))
+
+	var buf bytes.Buffer
+	if err := tmpl.Execute(&buf, h); err != nil {
+		log.Fatalln(err)
+	}
+
+	// at least two newlines
+	return strings.TrimSpace(regexp.MustCompile(`\n\n+`).ReplaceAllString(buf.String(), "\n\n"))
+}
+
+// CommandPadding computes the padding required to make all subcommand help
+// texts line up
+func (h *helpable) CommandPadding() int {
+	pad := 9
+	for _, c := range h.parentPtr.children {
+		l := len(c.Name())
+		if l > pad {
+			pad = l
+		}
+	}
+	return pad + 2
+}
+
+// Use returns the UseLine for the given command.
+// Parent command names are prepended
+func (h *helpable) Use() string {
+	use := h.Command.Use
+	if h.parentPtr != nil {
+		use = h.parentPtr.helpable().CommandPath() + " " + h.Command.Use
+	}
+
+	return fmt.Sprintf("%s [flags]", use)
+}
+
+// HasChildren reports whether this command has children
+func (h *helpable) HasChildren() bool {
+	return h.children != nil
+}
+
+// Children returns the children of this command.
+func (h *helpable) Children() []*helpable {
+	m := make([]*helpable, len(h.children))
+	for i, c := range h.children {
+		m[i] = c.helpable()
+	}
+	return m
+}
+
+// CommandPath returns the names of this and all parent commands joined, in the
+// same order as they would be specified on the command line.
+func (h *helpable) CommandPath() string {
+	if h.parentPtr != nil {
+		return fmt.Sprintf("%s %s", h.parentPtr.helpable().CommandPath(), h.Name())
+	}
+	return h.Name()
+}
diff --git a/vendor/github.com/go-clix/cli/predict.go b/vendor/github.com/go-clix/cli/predict.go
new file mode 100644
index 0000000..0c49a31
--- /dev/null
+++ b/vendor/github.com/go-clix/cli/predict.go
@@ -0,0 +1,87 @@
+package cli
+
+import (
+	"fmt"
+
+	"github.com/posener/complete"
+	"github.com/posener/complete/cmd/install"
+	"github.com/spf13/pflag"
+)
+
+// predict attempts to send <TAB> suggestions to bash.
+// Returns false if not running in a completion context
+func predict(c *Command) bool {
+	if c.Args == nil {
+		c.Args = ArgsAny()
+	}
+
+	cmp := complete.New(c.Name(), createCmp(c))
+	return cmp.Complete()
+}
+
+// createCmd returns the structure of the Command as a `complete.Command` for
+// the posener/complete library, including subcommands and flags.
+func createCmp(c *Command) complete.Command {
+	rootCmp := complete.Command{}
+
+	rootCmp.Flags = complete.Flags{
+		"-h":     complete.PredictNothing,
+		"--help": complete.PredictNothing,
+	}
+
+	c.Flags().VisitAll(func(flag *pflag.Flag) {
+		if flag.Hidden {
+			return
+		}
+
+		p, ok := c.Predictors[flag.Name]
+		if !ok {
+			p = complete.PredictNothing
+		}
+
+		if len(flag.Shorthand) > 0 {
+			rootCmp.Flags["-"+flag.Shorthand] = p
+		}
+		rootCmp.Flags["--"+flag.Name] = p
+	})
+
+	if c.children != nil {
+		rootCmp.Sub = make(complete.Commands)
+		for _, child := range c.children {
+			rootCmp.Sub[child.Name()] = createCmp(child)
+		}
+	}
+
+	// Positional Arguments
+	rootCmp.Args = c.Args
+	if rootCmp.Args == nil {
+		rootCmp.Args = PredictAny()
+	}
+
+	return rootCmp
+}
+
+// completionCmd returns a command that installs native completions into the
+// users shell.
+func completionCmd(name string) *Command {
+	cmd := &Command{
+		Use:   "complete",
+		Short: "install CLI completions",
+		Long: fmt.Sprintf(`Registers the %s binary as its own completion handler.
+This allows for richer <TAB> suggestions, because the actual application logic can be used to compute them.
+Installation is done by injecting a line into your shells startup script (.bashrc, .zshrc, .fishrc)`,
+			name),
+		Args: ArgsNone(),
+	}
+
+	del := cmd.Flags().Bool("remove", false, "uninstall completions")
+
+	cmd.Run = func(cmd *Command, args []string) error {
+		if *del {
+			return install.Uninstall(name)
+		}
+		return install.Install(name)
+	}
+
+	return cmd
+}
-- 
2.30.1

