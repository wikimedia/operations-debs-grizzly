From 50f2c401f7d589f5fb90079910dc20c9fdb9f810 Mon Sep 17 00:00:00 2001
From: Filippo Giunchedi <filippo@debian.org>
Date: Fri, 12 Mar 2021 10:15:12 +0100
Subject: [PATCH 2/3] vendor centrifugal

---
 .../centrifugal/centrifuge-go/.gitignore      |   30 +
 .../centrifugal/centrifuge-go/.travis.yml     |   17 +
 .../centrifugal/centrifuge-go/LICENSE         |   21 +
 .../centrifugal/centrifuge-go/README.md       |   47 +
 .../centrifugal/centrifuge-go/changelog.md    |   25 +
 .../centrifugal/centrifuge-go/client.go       | 1618 ++++
 .../centrifugal/centrifuge-go/config.go       |   66 +
 .../centrifugal/centrifuge-go/errors.go       |   21 +
 .../centrifugal/centrifuge-go/events.go       |  197 +
 .../centrifugal/centrifuge-go/go.mod          |    9 +
 .../centrifugal/centrifuge-go/go.sum          |   11 +
 .../centrifugal/centrifuge-go/protocol.go     |   96 +
 .../centrifugal/centrifuge-go/queue.go        |   79 +
 .../centrifugal/centrifuge-go/reconnect.go    |   45 +
 .../centrifugal/centrifuge-go/subscription.go |  548 ++
 .../centrifugal/centrifuge-go/transport.go    |   20 +
 .../centrifuge-go/transport_websocket.go      |  181 +
 .../centrifugal/protocol/.gitignore           |    3 +
 .../github.com/centrifugal/protocol/LICENSE   |   21 +
 .../github.com/centrifugal/protocol/Makefile  |   16 +
 .../centrifugal/protocol/client.pb.go         | 8403 +++++++++++++++++
 .../centrifugal/protocol/client.template      |  217 +
 .../github.com/centrifugal/protocol/decode.go |  654 ++
 .../github.com/centrifugal/protocol/encode.go |  404 +
 .../centrifugal/protocol/encoding.go          |   11 +
 .../github.com/centrifugal/protocol/error.go  |    9 +
 vendor/github.com/centrifugal/protocol/go.mod |    5 +
 vendor/github.com/centrifugal/protocol/go.sum |    5 +
 vendor/github.com/centrifugal/protocol/raw.go |   93 +
 .../github.com/centrifugal/protocol/readme.md |   12 +
 .../github.com/centrifugal/protocol/type.go   |   96 +
 31 files changed, 12980 insertions(+)
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/.gitignore
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/.travis.yml
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/LICENSE
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/README.md
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/changelog.md
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/client.go
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/config.go
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/errors.go
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/events.go
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/go.mod
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/go.sum
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/protocol.go
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/queue.go
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/reconnect.go
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/subscription.go
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/transport.go
 create mode 100644 vendor/github.com/centrifugal/centrifuge-go/transport_websocket.go
 create mode 100644 vendor/github.com/centrifugal/protocol/.gitignore
 create mode 100644 vendor/github.com/centrifugal/protocol/LICENSE
 create mode 100644 vendor/github.com/centrifugal/protocol/Makefile
 create mode 100644 vendor/github.com/centrifugal/protocol/client.pb.go
 create mode 100644 vendor/github.com/centrifugal/protocol/client.template
 create mode 100644 vendor/github.com/centrifugal/protocol/decode.go
 create mode 100644 vendor/github.com/centrifugal/protocol/encode.go
 create mode 100644 vendor/github.com/centrifugal/protocol/encoding.go
 create mode 100644 vendor/github.com/centrifugal/protocol/error.go
 create mode 100644 vendor/github.com/centrifugal/protocol/go.mod
 create mode 100644 vendor/github.com/centrifugal/protocol/go.sum
 create mode 100644 vendor/github.com/centrifugal/protocol/raw.go
 create mode 100644 vendor/github.com/centrifugal/protocol/readme.md
 create mode 100644 vendor/github.com/centrifugal/protocol/type.go

diff --git a/vendor/github.com/centrifugal/centrifuge-go/.gitignore b/vendor/github.com/centrifugal/centrifuge-go/.gitignore
new file mode 100644
index 0000000..10dd183
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/.gitignore
@@ -0,0 +1,30 @@
+.DS_Store
+vendor/
+
+# Compiled Object files, Static and Dynamic libs (Shared Objects)
+*.o
+*.a
+*.so
+
+# Folders
+_obj
+_test
+
+# Architecture specific extensions/prefixes
+*.[568vq]
+[568vq].out
+
+*.cgo1.go
+*.cgo2.c
+_cgo_defun.c
+_cgo_gotypes.go
+_cgo_export.*
+
+_testmain.go
+
+*.exe
+*.test
+*.prof
+
+.idea/
+.vscode/
diff --git a/vendor/github.com/centrifugal/centrifuge-go/.travis.yml b/vendor/github.com/centrifugal/centrifuge-go/.travis.yml
new file mode 100644
index 0000000..a27a094
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/.travis.yml
@@ -0,0 +1,17 @@
+language: go
+
+env:
+  - GO111MODULE=on
+
+services:
+  - docker
+
+before_install:
+  - docker pull centrifugo/centrifugo
+  - docker run -d -p 8000:8000 centrifugo/centrifugo centrifugo --client_insecure
+go:
+  - "1.14.x"
+  - "1.13.x"
+  - "tip"
+
+script: go test -race -v
diff --git a/vendor/github.com/centrifugal/centrifuge-go/LICENSE b/vendor/github.com/centrifugal/centrifuge-go/LICENSE
new file mode 100644
index 0000000..bbd5ae2
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/LICENSE
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2018 Centrifugal
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/vendor/github.com/centrifugal/centrifuge-go/README.md b/vendor/github.com/centrifugal/centrifuge-go/README.md
new file mode 100644
index 0000000..21cd2c0
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/README.md
@@ -0,0 +1,47 @@
+Websocket client for [Centrifuge](https://github.com/centrifugal/centrifuge) library and [Centrifugo](https://github.com/centrifugal/centrifugo) server.
+
+Documentation
+-------------
+
+[API documentation on Godoc](https://godoc.org/github.com/centrifugal/centrifuge-go)
+
+There is no v1 release of this library yet, API is not stable – so use with tools like `dep` or `go mod`.
+
+Feature matrix
+--------------
+
+- [x] connect to server using JSON protocol format
+- [x] connect to server using Protobuf protocol format
+- [x] connect with JWT
+- [x] connect with custom header
+- [x] automatic reconnect in case of errors, network problems etc
+- [x] an exponential backoff for reconnect
+- [x] connect and disconnect events
+- [x] handle disconnect reason
+- [x] subscribe on a channel and handle asynchronous Publications
+- [x] handle Join and Leave messages
+- [x] handle Unsubscribe notifications
+- [x] reconnect on subscribe timeout
+- [x] publish method of Subscription
+- [x] unsubscribe method of Subscription
+- [x] presence method of Subscription
+- [x] presence stats method of Subscription
+- [x] history method of Subscription
+- [x] send asynchronous messages to server
+- [x] handle asynchronous messages from server
+- [x] send RPC commands
+- [x] publish to channel without being subscribed
+- [x] subscribe to private channels with JWT
+- [x] connection token (JWT) refresh
+- [ ] private channel subscription token (JWT) refresh
+- [x] handle connection expired error
+- [ ] handle subscription expired error
+- [x] ping/pong to find broken connection
+- [x] server-side subscriptions
+- [x] message recovery mechanism for client-side subscriptions
+- [x] message recovery mechanism for server-side subscriptions
+
+License
+-------
+
+MIT
diff --git a/vendor/github.com/centrifugal/centrifuge-go/changelog.md b/vendor/github.com/centrifugal/centrifuge-go/changelog.md
new file mode 100644
index 0000000..7642c69
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/changelog.md
@@ -0,0 +1,25 @@
+v0.6.2
+======
+
+* fix deadlock on a private channel resubscribe - see [#38](https://github.com/centrifugal/centrifuge-go/pull/38)
+
+v0.6.1
+======
+
+* fix setting server-side unsubscribe handler, call server-side unsubscribe event on disconnect 
+
+v0.6.0
+======
+
+* server-side subscriptions support
+* get rid of Protobuf protocol struct `Publication` and `ClientInfo` aliases – use library scope structures instead
+* change return values of `RPC`, `NamedRPC`, `History`, `Presence`, `PresenceStats`, `Publish` methods to be more meaningful and extensible
+* much faster resubscribe to many subscriptions (previously we waited for each individual subscription response before moving further, now process is asynchronous)
+* improved reconnect logic
+* Client and Subscription status refactoring
+* fix inconsistent join/subscribe event ordering – now both processed in order coming from server
+
+v0.5.2
+======
+
+* `NamedRPC` method added - [#35](https://github.com/centrifugal/centrifuge-go/pull/35), thanks [@L11R](https://github.com/L11R)
diff --git a/vendor/github.com/centrifugal/centrifuge-go/client.go b/vendor/github.com/centrifugal/centrifuge-go/client.go
new file mode 100644
index 0000000..79cb35e
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/client.go
@@ -0,0 +1,1618 @@
+package centrifuge
+
+import (
+	"errors"
+	"fmt"
+	"io"
+	"net/http"
+	"strings"
+	"sync"
+	"sync/atomic"
+	"time"
+
+	"github.com/centrifugal/protocol"
+)
+
+type disconnect struct {
+	Reason    string
+	Reconnect bool
+}
+
+// Describe client connection statuses.
+const (
+	DISCONNECTED = iota
+	CONNECTING
+	CONNECTED
+	CLOSED
+)
+
+const defaultClientName = "go"
+
+type serverSub struct {
+	Offset      uint64
+	Epoch       string
+	Recoverable bool
+}
+
+// Client represents client connection to Centrifugo or Centrifuge
+// library based server. It provides methods to set various event
+// handlers, subscribe to channels, call RPC commands etc. Call client
+// Connect method to trigger actual connection with server. Call client
+// Close method to clean up state when you don't need client instance
+// anymore.
+type Client struct {
+	mu                  sync.RWMutex
+	url                 string
+	encoding            protocol.Type
+	config              Config
+	token               string
+	name                string
+	version             string
+	connectData         protocol.Raw
+	transport           transport
+	msgID               uint32
+	status              int
+	id                  string
+	subs                map[string]*Subscription
+	serverSubs          map[string]*serverSub
+	requestsMu          sync.RWMutex
+	requests            map[uint32]request
+	receive             chan []byte
+	reconnect           bool
+	reconnectAttempts   int
+	reconnectStrategy   reconnectStrategy
+	events              *eventHub
+	paramsEncoder       protocol.ParamsEncoder
+	resultDecoder       protocol.ResultDecoder
+	commandEncoder      protocol.CommandEncoder
+	pushEncoder         protocol.PushEncoder
+	pushDecoder         protocol.PushDecoder
+	delayPing           chan struct{}
+	reconnectCh         chan struct{}
+	closeCh             chan struct{}
+	futureID            uint64
+	connectFutures      map[uint64]connectFuture
+	hasBeenDisconnected bool
+	cbQueue             *cbQueue
+}
+
+func (c *Client) nextMsgID() uint32 {
+	return atomic.AddUint32(&c.msgID, 1)
+}
+
+// New initializes Client. After client initialized call its Connect method
+// to trigger connection establishment with server.
+func New(u string, config Config) *Client {
+	var encoding protocol.Type
+
+	if strings.HasPrefix(u, "ws") {
+		if strings.Contains(u, "format=protobuf") {
+			encoding = protocol.TypeProtobuf
+		} else {
+			encoding = protocol.TypeJSON
+		}
+	} else {
+		panic(fmt.Sprintf("unsupported connection endpoint: %s", u))
+	}
+
+	c := &Client{
+		url:               u,
+		name:              defaultClientName,
+		config:            config,
+		status:            DISCONNECTED,
+		encoding:          encoding,
+		subs:              make(map[string]*Subscription),
+		serverSubs:        make(map[string]*serverSub),
+		requests:          make(map[uint32]request),
+		reconnectStrategy: defaultBackoffReconnect,
+		paramsEncoder:     newParamsEncoder(encoding),
+		resultDecoder:     newResultDecoder(encoding),
+		commandEncoder:    newCommandEncoder(encoding),
+		pushEncoder:       newPushEncoder(encoding),
+		pushDecoder:       newPushDecoder(encoding),
+		delayPing:         make(chan struct{}, 32),
+		reconnectCh:       make(chan struct{}, 1),
+		closeCh:           make(chan struct{}),
+		events:            newEventHub(),
+		reconnect:         true,
+		connectFutures:    make(map[uint64]connectFuture),
+	}
+
+	// Create the async callback queue.
+	c.cbQueue = &cbQueue{}
+	c.cbQueue.cond = sync.NewCond(&c.cbQueue.mu)
+	go c.cbQueue.dispatch()
+
+	// Start reconnect management goroutine.
+	go c.reconnectRoutine()
+
+	return c
+}
+
+// SetToken allows to set connection token to let client
+// authenticate itself on connect.
+func (c *Client) SetToken(token string) {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	c.token = token
+}
+
+// SetName allows to set client name. You should only use a limited
+// amount of client names throughout your applications – i.e. don't
+// make it unique per user for example, this name describes environment
+// from which client connects.
+func (c *Client) SetName(name string) {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	c.name = name
+}
+
+// SetVersion allows to set client version. This is an application
+// specific information.
+func (c *Client) SetVersion(version string) {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	c.version = version
+}
+
+// SetConnectData allows to set data to send in connect command.
+func (c *Client) SetConnectData(data []byte) {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	c.connectData = data
+}
+
+// SetHeader allows to set custom header to be sent in Upgrade HTTP request.
+func (c *Client) SetHeader(key, value string) {
+	if c.config.Header == nil {
+		c.config.Header = http.Header{}
+	}
+	c.config.Header.Set(key, value)
+}
+
+func (c *Client) connected() bool {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+	return c.status == CONNECTED
+}
+
+func (c *Client) subscribed(channel string) bool {
+	c.mu.RLock()
+	_, ok := c.subs[channel]
+	c.mu.RUnlock()
+	return ok
+}
+
+// clientID returns unique ID of this connection which is set by server after connect.
+// It only available after connection was established and authorized.
+func (c *Client) clientID() string {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+	return c.id
+}
+
+func (c *Client) handleError(err error) {
+	var handler ErrorHandler
+	if c.events != nil && c.events.onError != nil {
+		handler = c.events.onError
+	}
+	if handler != nil {
+		c.runHandler(func() {
+			handler.OnError(c, ErrorEvent{Message: err.Error()})
+		})
+	}
+}
+
+// Send message to server without waiting for response.
+// Message handler must be registered on server.
+func (c *Client) Send(data []byte) error {
+	cmd := &protocol.Command{
+		Method: protocol.MethodTypeSend,
+	}
+	params := &protocol.SendRequest{
+		Data: data,
+	}
+	paramsData, err := c.paramsEncoder.Encode(params)
+	if err != nil {
+		return err
+	}
+	cmd.Params = paramsData
+	return c.send(cmd)
+}
+
+// RPCResult contains data returned from server as RPC result.
+type RPCResult struct {
+	Data []byte
+}
+
+// RPC allows to make RPC – send data to server and wait for response.
+// RPC handler must be registered on server.
+func (c *Client) RPC(data []byte) (RPCResult, error) {
+	return c.NamedRPC("", data)
+}
+
+// NamedRPC allows to make RPC – send data to server ant wait for response.
+// RPC handler must be registered on server.
+// In contrast to RPC method it allows to pass method name.
+func (c *Client) NamedRPC(method string, data []byte) (RPCResult, error) {
+	resCh := make(chan RPCResult, 1)
+	errCh := make(chan error, 1)
+	c.rpc(method, data, func(result RPCResult, err error) {
+		resCh <- result
+		errCh <- err
+	})
+	return <-resCh, <-errCh
+}
+
+func (c *Client) rpc(method string, data []byte, fn func(RPCResult, error)) {
+	cmd := &protocol.Command{
+		ID:     c.nextMsgID(),
+		Method: protocol.MethodTypeRPC,
+	}
+	params := &protocol.RPCRequest{
+		Data:   data,
+		Method: method,
+	}
+	paramsData, err := c.paramsEncoder.Encode(params)
+	if err != nil {
+		fn(RPCResult{}, fmt.Errorf("encode error: %v", err))
+		return
+	}
+	cmd.Params = paramsData
+	err = c.sendAsync(cmd, func(r protocol.Reply, err error) {
+		if err != nil {
+			fn(RPCResult{}, err)
+			return
+		}
+		if r.Error != nil {
+			fn(RPCResult{}, r.Error)
+			return
+		}
+		var res protocol.RPCResult
+		err = c.resultDecoder.Decode(r.Result, &res)
+		if err != nil {
+			fn(RPCResult{}, err)
+			return
+		}
+		fn(RPCResult{Data: res.Data}, nil)
+	})
+	if err != nil {
+		fn(RPCResult{}, err)
+		return
+	}
+}
+
+// Close closes Client forever and cleans up state.
+func (c *Client) Close() error {
+	err := c.Disconnect()
+	c.mu.Lock()
+	if c.status == CLOSED {
+		c.mu.Unlock()
+		return nil
+	}
+	c.cbQueue.close()
+	close(c.closeCh)
+	c.status = CLOSED
+	c.mu.Unlock()
+	return err
+}
+
+// reconnectRoutine manages re-connections to a server. It does this using
+// reconnectStrategy which is exponential back-off by default. It also ensures
+// that no more than one connection attempt happens concurrently.
+func (c *Client) reconnectRoutine() {
+	var semaphore chan struct{}
+	for {
+		select {
+		case <-c.closeCh:
+			return
+		case _, ok := <-c.reconnectCh:
+			if !ok {
+				return
+			}
+			if semaphore != nil {
+				<-semaphore
+			}
+			semaphore = make(chan struct{}, 1)
+			c.mu.RLock()
+			duration, err := c.reconnectStrategy.timeBeforeNextAttempt(c.reconnectAttempts)
+			c.mu.RUnlock()
+			if err != nil {
+				c.handleError(err)
+				return
+			}
+			select {
+			case <-c.closeCh:
+			case <-time.After(duration):
+			}
+			c.mu.Lock()
+			if c.status != CONNECTING {
+				c.mu.Unlock()
+				semaphore <- struct{}{}
+				continue
+			}
+			c.reconnectAttempts++
+			if !c.reconnect {
+				c.mu.Unlock()
+				semaphore <- struct{}{}
+				continue
+			}
+			c.mu.Unlock()
+			err = c.connectFromScratch(true, func() {
+				semaphore <- struct{}{}
+			})
+			if err != nil {
+				c.handleError(err)
+			}
+		}
+	}
+}
+
+func (c *Client) handleDisconnect(d *disconnect) {
+	if d == nil {
+		d = &disconnect{
+			Reason:    "connection closed",
+			Reconnect: true,
+		}
+	}
+
+	c.mu.Lock()
+	if c.status == DISCONNECTED || c.status == CLOSED {
+		c.mu.Unlock()
+		return
+	}
+
+	c.requestsMu.Lock()
+	reqs := make(map[uint32]request, len(c.requests))
+	for uid, req := range c.requests {
+		reqs[uid] = req
+	}
+	c.requests = make(map[uint32]request)
+	c.requestsMu.Unlock()
+
+	if c.transport != nil {
+		_ = c.transport.Close()
+		c.transport = nil
+	}
+
+	subsToUnsubscribe := make([]*Subscription, 0, len(c.subs))
+	for _, s := range c.subs {
+		subsToUnsubscribe = append(subsToUnsubscribe, s)
+	}
+	serverSubsToUnsubscribe := make([]string, 0, len(c.serverSubs))
+	for ch := range c.serverSubs {
+		serverSubsToUnsubscribe = append(serverSubsToUnsubscribe, ch)
+	}
+
+	needDisconnectEvent := !c.hasBeenDisconnected || c.status == CONNECTED
+	c.reconnect = d.Reconnect
+	if c.reconnect {
+		c.status = CONNECTING
+	} else {
+		c.resolveConnectFutures(ErrClientDisconnected)
+		c.status = DISCONNECTED
+	}
+	c.hasBeenDisconnected = true
+	c.mu.Unlock()
+
+	for _, req := range reqs {
+		if req.cb != nil {
+			req.cb(protocol.Reply{}, ErrClientDisconnected)
+		}
+	}
+
+	for _, s := range subsToUnsubscribe {
+		s.triggerOnUnsubscribe(true, d.Reconnect)
+	}
+
+	var handler DisconnectHandler
+	if c.events != nil && c.events.onDisconnect != nil {
+		handler = c.events.onDisconnect
+	}
+
+	var serverUnsubscribeHandler ServerUnsubscribeHandler
+	if c.events != nil && c.events.onServerUnsubscribe != nil {
+		serverUnsubscribeHandler = c.events.onServerUnsubscribe
+	}
+
+	if handler != nil && needDisconnectEvent {
+		c.runHandler(func() {
+			if serverUnsubscribeHandler != nil {
+				for _, ch := range serverSubsToUnsubscribe {
+					serverUnsubscribeHandler.OnServerUnsubscribe(c, ServerUnsubscribeEvent{Channel: ch})
+				}
+			}
+			handler.OnDisconnect(c, DisconnectEvent{Reason: d.Reason, Reconnect: d.Reconnect})
+		})
+	}
+
+	if !d.Reconnect {
+		return
+	}
+
+	select {
+	case c.reconnectCh <- struct{}{}:
+	default:
+	}
+}
+
+func (c *Client) periodicPing(closeCh chan struct{}) {
+	timeout := c.config.PingInterval
+	for {
+		select {
+		case <-c.delayPing:
+		case <-time.After(timeout):
+			c.sendPing(func(err error) {
+				if err != nil {
+					go c.handleDisconnect(&disconnect{Reason: "no ping", Reconnect: true})
+					return
+				}
+			})
+		case <-closeCh:
+			return
+		}
+	}
+}
+
+func (c *Client) readOnce(t transport) error {
+	reply, disconnect, err := t.Read()
+	if err != nil {
+		go c.handleDisconnect(disconnect)
+		return err
+	}
+	select {
+	case c.delayPing <- struct{}{}:
+	default:
+	}
+	err = c.handle(reply)
+	if err != nil {
+		c.handleError(err)
+	}
+	return nil
+}
+
+func (c *Client) reader(t transport, closeCh chan struct{}) {
+	defer close(closeCh)
+	for {
+		err := c.readOnce(t)
+		if err != nil {
+			return
+		}
+	}
+}
+
+func (c *Client) runHandler(fn func()) {
+	c.cbQueue.push(fn)
+}
+
+func (c *Client) handle(reply *protocol.Reply) error {
+	if reply.ID > 0 {
+		c.requestsMu.RLock()
+		req, ok := c.requests[reply.ID]
+		c.requestsMu.RUnlock()
+		if ok {
+			if req.cb != nil {
+				req.cb(*reply, nil)
+			}
+		}
+		c.removeRequest(reply.ID)
+	} else {
+		push, err := c.pushDecoder.Decode(reply.Result)
+		if err != nil {
+			return err
+		}
+		err = c.handlePush(*push)
+		if err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func (c *Client) handleMessage(msg protocol.Message) error {
+
+	var handler MessageHandler
+	if c.events != nil && c.events.onMessage != nil {
+		handler = c.events.onMessage
+	}
+
+	if handler != nil {
+		event := MessageEvent{Data: msg.Data}
+		c.runHandler(func() {
+			handler.OnMessage(c, event)
+		})
+	}
+
+	return nil
+}
+
+func (c *Client) handlePush(msg protocol.Push) error {
+	switch msg.Type {
+	case protocol.PushTypeMessage:
+		m, err := c.pushDecoder.DecodeMessage(msg.Data)
+		if err != nil {
+			return err
+		}
+		_ = c.handleMessage(*m)
+	case protocol.PushTypeUnsub:
+		m, err := c.pushDecoder.DecodeUnsub(msg.Data)
+		if err != nil {
+			return err
+		}
+		channel := msg.Channel
+		c.mu.RLock()
+		sub, ok := c.subs[channel]
+		c.mu.RUnlock()
+		if !ok {
+			return c.handleServerUnsub(channel, *m)
+		}
+		sub.handleUnsub(*m)
+	case protocol.PushTypePublication:
+		m, err := c.pushDecoder.DecodePublication(msg.Data)
+		if err != nil {
+			return err
+		}
+		channel := msg.Channel
+		c.mu.RLock()
+		sub, ok := c.subs[channel]
+		c.mu.RUnlock()
+		if !ok {
+			return c.handleServerPublication(channel, *m)
+		}
+		sub.handlePublication(*m)
+	case protocol.PushTypeJoin:
+		m, err := c.pushDecoder.DecodeJoin(msg.Data)
+		if err != nil {
+			return nil
+		}
+		channel := msg.Channel
+		c.mu.RLock()
+		sub, ok := c.subs[channel]
+		c.mu.RUnlock()
+		if !ok {
+			return c.handleServerJoin(channel, *m)
+		}
+		sub.handleJoin(m.Info)
+	case protocol.PushTypeLeave:
+		m, err := c.pushDecoder.DecodeLeave(msg.Data)
+		if err != nil {
+			return nil
+		}
+		channel := msg.Channel
+		c.mu.RLock()
+		sub, ok := c.subs[channel]
+		c.mu.RUnlock()
+		if !ok {
+			return c.handleServerLeave(channel, *m)
+		}
+		sub.handleLeave(m.Info)
+	case protocol.PushTypeSub:
+		m, err := c.pushDecoder.DecodeSub(msg.Data)
+		if err != nil {
+			return nil
+		}
+		channel := msg.Channel
+		c.mu.RLock()
+		_, ok := c.subs[channel]
+		c.mu.RUnlock()
+		if ok {
+			// Client-side subscription exists.
+			return nil
+		}
+		return c.handleServerSub(channel, *m)
+	default:
+		return nil
+	}
+	return nil
+}
+
+func (c *Client) handleServerPublication(channel string, pub protocol.Publication) error {
+	c.mu.RLock()
+	_, ok := c.serverSubs[channel]
+	c.mu.RUnlock()
+	if !ok {
+		return nil
+	}
+
+	var handler ServerPublishHandler
+	if c.events != nil && c.events.onServerPublish != nil {
+		handler = c.events.onServerPublish
+	}
+	if handler != nil {
+		c.runHandler(func() {
+			handler.OnServerPublish(c, ServerPublishEvent{Channel: channel, Publication: pubFromProto(pub)})
+			c.mu.Lock()
+			serverSub, ok := c.serverSubs[channel]
+			if !ok {
+				c.mu.Unlock()
+				return
+			}
+			serverSub.Offset = pub.Offset
+			c.mu.Unlock()
+		})
+	}
+	return nil
+}
+
+func (c *Client) handleServerJoin(channel string, join protocol.Join) error {
+	c.mu.RLock()
+	_, ok := c.serverSubs[channel]
+	c.mu.RUnlock()
+	if !ok {
+		return nil
+	}
+	var handler ServerJoinHandler
+	if c.events != nil && c.events.onServerJoin != nil {
+		handler = c.events.onServerJoin
+	}
+	if handler != nil {
+		c.runHandler(func() {
+			handler.OnServerJoin(c, ServerJoinEvent{Channel: channel, ClientInfo: infoFromProto(join.Info)})
+		})
+	}
+	return nil
+}
+
+func (c *Client) handleServerLeave(channel string, leave protocol.Leave) error {
+	c.mu.RLock()
+	_, ok := c.serverSubs[channel]
+	c.mu.RUnlock()
+	if !ok {
+		return nil
+	}
+
+	var handler ServerLeaveHandler
+	if c.events != nil && c.events.onServerLeave != nil {
+		handler = c.events.onServerLeave
+	}
+	if handler != nil {
+		c.runHandler(func() {
+			handler.OnServerLeave(c, ServerLeaveEvent{Channel: channel, ClientInfo: infoFromProto(leave.Info)})
+		})
+	}
+	return nil
+}
+
+func (c *Client) handleServerSub(channel string, sub protocol.Sub) error {
+	c.mu.Lock()
+	_, ok := c.serverSubs[channel]
+	if ok {
+		return nil
+	}
+	c.serverSubs[channel] = &serverSub{
+		Offset:      sub.Offset,
+		Epoch:       sub.Epoch,
+		Recoverable: sub.Recoverable,
+	}
+	c.mu.Unlock()
+	if !ok {
+		return nil
+	}
+
+	var handler ServerSubscribeHandler
+	if c.events != nil && c.events.onServerSubscribe != nil {
+		handler = c.events.onServerSubscribe
+	}
+	if handler != nil {
+		c.runHandler(func() {
+			handler.OnServerSubscribe(c, ServerSubscribeEvent{Channel: channel, Resubscribed: false, Recovered: false})
+		})
+	}
+	return nil
+}
+
+func (c *Client) handleServerUnsub(channel string, _ protocol.Unsub) error {
+	c.mu.Lock()
+	_, ok := c.serverSubs[channel]
+	if ok {
+		delete(c.serverSubs, channel)
+	}
+	c.mu.Unlock()
+	if !ok {
+		return nil
+	}
+
+	var handler ServerUnsubscribeHandler
+	if c.events != nil && c.events.onServerUnsubscribe != nil {
+		handler = c.events.onServerUnsubscribe
+	}
+	if handler != nil {
+		c.runHandler(func() {
+			handler.OnServerUnsubscribe(c, ServerUnsubscribeEvent{Channel: channel})
+		})
+	}
+	return nil
+}
+
+// Connect dials to server and sends connect message. Will return an error if first dial
+// with server failed. In case of failure client will automatically reconnect with
+// exponential backoff.
+func (c *Client) Connect() error {
+	return c.connectFromScratch(false, func() {})
+}
+
+func (c *Client) connectFromScratch(isReconnect bool, reconnectWaitCB func()) error {
+	c.mu.Lock()
+	if isReconnect && c.status == DISCONNECTED {
+		c.mu.Unlock()
+		reconnectWaitCB()
+		return nil
+	}
+	if c.status == CLOSED {
+		c.mu.Unlock()
+		reconnectWaitCB()
+		return ErrClientClosed
+	}
+	c.status = CONNECTING
+	c.reconnect = true
+	c.mu.Unlock()
+
+	wsConfig := websocketConfig{
+		NetDialContext:    c.config.NetDialContext,
+		TLSConfig:         c.config.TLSConfig,
+		HandshakeTimeout:  c.config.HandshakeTimeout,
+		EnableCompression: c.config.EnableCompression,
+		CookieJar:         c.config.CookieJar,
+		Header:            c.config.Header,
+	}
+
+	t, err := newWebsocketTransport(c.url, c.encoding, wsConfig)
+	if err != nil {
+		go c.handleDisconnect(&disconnect{Reason: "connect error", Reconnect: true})
+		reconnectWaitCB()
+		return err
+	}
+
+	c.mu.Lock()
+	if c.status == CONNECTED || c.status == DISCONNECTED || c.status == CLOSED {
+		_ = t.Close()
+		c.mu.Unlock()
+		reconnectWaitCB()
+		return nil
+	}
+
+	closeCh := make(chan struct{})
+	c.receive = make(chan []byte, 64)
+	c.transport = t
+	go c.reader(t, closeCh)
+	err = c.sendConnect(isReconnect, func(res protocol.ConnectResult, err error) {
+		defer reconnectWaitCB()
+		c.mu.Lock()
+		if c.status != CONNECTING {
+			c.mu.Unlock()
+			return
+		}
+		c.mu.Unlock()
+		if err != nil {
+			if isTokenExpiredError(err) {
+				// Try to refresh token before next connection attempt.
+				_ = c.refreshToken()
+				c.mu.Lock()
+				if c.status != CONNECTING {
+					c.mu.Unlock()
+					return
+				}
+				c.mu.Unlock()
+			}
+			go c.handleDisconnect(&disconnect{Reason: "connect error", Reconnect: true})
+			return
+		}
+
+		c.mu.Lock()
+		if c.status != CONNECTING {
+			c.mu.Unlock()
+			return
+		}
+		c.id = res.Client
+		prevStatus := c.status
+		c.status = CONNECTED
+
+		if res.Expires {
+			go func(interval uint32, closeCh chan struct{}) {
+				select {
+				case <-closeCh:
+					return
+				case <-time.After(time.Duration(interval) * time.Second):
+					c.sendRefresh(closeCh)
+				}
+			}(res.TTL, closeCh)
+		}
+		c.resolveConnectFutures(nil)
+		c.mu.Unlock()
+
+		if c.events != nil && c.events.onConnect != nil && prevStatus != CONNECTED {
+			handler := c.events.onConnect
+			ev := ConnectEvent{
+				ClientID: c.clientID(),
+				Version:  res.Version,
+				Data:     res.Data,
+			}
+			c.runHandler(func() {
+				handler.OnConnect(c, ev)
+			})
+		}
+
+		var subscribeHandler ServerSubscribeHandler
+		if c.events != nil && c.events.onServerSubscribe != nil {
+			subscribeHandler = c.events.onServerSubscribe
+		}
+
+		var publishHandler ServerPublishHandler
+		if c.events != nil && c.events.onServerPublish != nil {
+			publishHandler = c.events.onServerPublish
+		}
+
+		for channel, subRes := range res.Subs {
+			c.mu.Lock()
+			sub, ok := c.serverSubs[channel]
+			if ok {
+				sub.Epoch = subRes.Epoch
+				sub.Recoverable = subRes.Recoverable
+			} else {
+				sub = &serverSub{
+					Epoch:       subRes.Epoch,
+					Offset:      subRes.Offset,
+					Recoverable: subRes.Recoverable,
+				}
+			}
+			if len(subRes.Publications) == 0 {
+				sub.Offset = subRes.Offset
+			}
+			c.serverSubs[channel] = sub
+			c.mu.Unlock()
+
+			if subscribeHandler != nil {
+				c.runHandler(func() {
+					subscribeHandler.OnServerSubscribe(c, ServerSubscribeEvent{
+						Channel:      channel,
+						Resubscribed: isReconnect, // TODO: check request map.
+						Recovered:    subRes.Recovered,
+					})
+				})
+			}
+			if publishHandler != nil {
+				c.runHandler(func() {
+					for _, pub := range subRes.Publications {
+						publishHandler.OnServerPublish(c, ServerPublishEvent{Channel: channel, Publication: pubFromProto(*pub)})
+						c.mu.Lock()
+						if sub, ok := c.serverSubs[channel]; ok {
+							sub.Offset = pub.Offset
+						}
+						c.serverSubs[channel] = sub
+						c.mu.Unlock()
+					}
+				})
+			}
+		}
+
+		c.mu.Lock()
+		defer c.mu.Unlock()
+
+		if c.status != CONNECTED {
+			return
+		}
+
+		err = c.resubscribe(c.id)
+		if err != nil {
+			// we need just to close the connection and outgoing requests here
+			// but preserve all subscriptions.
+			go c.handleDisconnect(&disconnect{Reason: "subscribe error", Reconnect: true})
+			return
+		}
+
+		// Successfully connected – can reset reconnect attempts.
+		c.reconnectAttempts = 0
+
+		go c.periodicPing(closeCh)
+	})
+	c.mu.Unlock()
+	if err != nil {
+		reconnectWaitCB()
+		go c.handleDisconnect(&disconnect{Reason: "connect error", Reconnect: true})
+	}
+	return err
+}
+
+func (c *Client) resubscribe(clientID string) error {
+	for _, sub := range c.subs {
+		err := sub.resubscribe(true, clientID)
+		if err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func isTokenExpiredError(err error) bool {
+	if e, ok := err.(*protocol.Error); ok && e.Code == 109 {
+		return true
+	}
+	return false
+}
+
+func (c *Client) disconnect(reconnect bool) error {
+	c.mu.Lock()
+	c.reconnect = reconnect
+	c.mu.Unlock()
+	c.handleDisconnect(&disconnect{
+		Reconnect: reconnect,
+		Reason:    "clean disconnect",
+	})
+	return nil
+}
+
+// Disconnect client from server.
+func (c *Client) Disconnect() error {
+	return c.disconnect(false)
+}
+
+func (c *Client) refreshToken() error {
+	var handler RefreshHandler
+	if c.events != nil && c.events.onRefresh != nil {
+		handler = c.events.onRefresh
+	}
+	if handler == nil {
+		return errors.New("RefreshHandler must be set to handle expired token")
+	}
+
+	token, err := handler.OnRefresh(c)
+	if err != nil {
+		return err
+	}
+	c.mu.Lock()
+	c.token = token
+	c.mu.Unlock()
+	return nil
+}
+
+func (c *Client) sendRefresh(closeCh chan struct{}) {
+	err := c.refreshToken()
+	if err != nil {
+		return
+	}
+
+	c.mu.RLock()
+	cmd := &protocol.Command{
+		ID:     c.nextMsgID(),
+		Method: protocol.MethodTypeRefresh,
+	}
+	params := &protocol.RefreshRequest{
+		Token: c.token,
+	}
+	paramsData, err := c.paramsEncoder.Encode(params)
+	if err != nil {
+		c.mu.RUnlock()
+		return
+	}
+	cmd.Params = paramsData
+	c.mu.RUnlock()
+
+	_ = c.sendAsync(cmd, func(r protocol.Reply, err error) {
+		if err != nil {
+			return
+		}
+		if r.Error != nil {
+			return
+		}
+		var res protocol.RefreshResult
+		err = c.resultDecoder.Decode(r.Result, &res)
+		if err != nil {
+			return
+		}
+		if res.Expires {
+			go func(interval uint32) {
+				select {
+				case <-closeCh:
+					return
+				case <-time.After(time.Duration(interval) * time.Second):
+					c.sendRefresh(closeCh)
+				}
+			}(res.TTL)
+		}
+	})
+}
+
+func (c *Client) sendSubRefresh(channel string, fn func(protocol.SubRefreshResult, error)) {
+	c.mu.RLock()
+	clientID := c.id
+	c.mu.RUnlock()
+
+	token, err := c.privateSign(channel, clientID)
+	if err != nil {
+		return
+	}
+
+	c.mu.RLock()
+	if c.id != clientID {
+		c.mu.RUnlock()
+		return
+	}
+	cmd := &protocol.Command{
+		ID:     c.nextMsgID(),
+		Method: protocol.MethodTypeSubRefresh,
+	}
+	params := &protocol.SubRefreshRequest{
+		Channel: channel,
+		Token:   token,
+	}
+	paramsData, err := c.paramsEncoder.Encode(params)
+	if err != nil {
+		c.mu.RUnlock()
+		fn(protocol.SubRefreshResult{}, err)
+		return
+	}
+	cmd.Params = paramsData
+	c.mu.RUnlock()
+
+	_ = c.sendAsync(cmd, func(r protocol.Reply, err error) {
+		if err != nil {
+			fn(protocol.SubRefreshResult{}, err)
+			return
+		}
+		if r.Error != nil {
+			fn(protocol.SubRefreshResult{}, r.Error)
+			return
+		}
+		var res protocol.SubRefreshResult
+		err = c.resultDecoder.Decode(r.Result, &res)
+		if err != nil {
+			fn(protocol.SubRefreshResult{}, err)
+			return
+		}
+		fn(res, nil)
+	})
+}
+
+func (c *Client) sendConnect(isReconnect bool, fn func(protocol.ConnectResult, error)) error {
+	cmd := &protocol.Command{
+		ID:     c.nextMsgID(),
+		Method: protocol.MethodTypeConnect,
+	}
+
+	if c.token != "" || c.connectData != nil || len(c.serverSubs) > 0 || c.name != "" || c.version != "" {
+		params := &protocol.ConnectRequest{}
+		if c.token != "" {
+			params.Token = c.token
+		}
+		if c.name != "" {
+			params.Name = c.name
+		}
+		if c.version != "" {
+			params.Version = c.version
+		}
+		if c.connectData != nil {
+			params.Data = c.connectData
+		}
+		if isReconnect && len(c.serverSubs) > 0 {
+			subs := make(map[string]*protocol.SubscribeRequest)
+			for channel, serverSub := range c.serverSubs {
+				if !serverSub.Recoverable {
+					continue
+				}
+				subs[channel] = &protocol.SubscribeRequest{
+					Recover: true,
+					Epoch:   serverSub.Epoch,
+					Offset:  serverSub.Offset,
+				}
+			}
+			params.Subs = subs
+		}
+		paramsData, err := c.paramsEncoder.Encode(params)
+		if err != nil {
+			return err
+		}
+		cmd.Params = paramsData
+	}
+
+	return c.sendAsync(cmd, func(reply protocol.Reply, err error) {
+		if err != nil {
+			fn(protocol.ConnectResult{}, err)
+			return
+		}
+		if reply.Error != nil {
+			fn(protocol.ConnectResult{}, reply.Error)
+			return
+		}
+
+		var res protocol.ConnectResult
+		err = c.resultDecoder.Decode(reply.Result, &res)
+		if err != nil {
+			fn(protocol.ConnectResult{}, err)
+			return
+		}
+		fn(res, nil)
+	})
+}
+
+func (c *Client) privateSign(channel string, clientID string) (string, error) {
+	var token string
+	if strings.HasPrefix(channel, c.config.PrivateChannelPrefix) && c.events != nil {
+		handler := c.events.onPrivateSub
+		if handler != nil {
+			ev := PrivateSubEvent{
+				ClientID: clientID,
+				Channel:  channel,
+			}
+			ps, err := handler.OnPrivateSub(c, ev)
+			if err != nil {
+				return "", err
+			}
+			token = ps
+		} else {
+			return "", errors.New("PrivateSubHandler must be set to handle private channel subscriptions")
+		}
+	}
+	return token, nil
+}
+
+// NewSubscription allows to create new subscription on channel.
+func (c *Client) NewSubscription(channel string) (*Subscription, error) {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	var sub *Subscription
+	if _, ok := c.subs[channel]; ok {
+		return nil, ErrDuplicateSubscription
+	}
+	sub = c.newSubscription(channel)
+	c.subs[channel] = sub
+	return sub, nil
+}
+
+type streamPosition struct {
+	Seq    uint32
+	Gen    uint32
+	Offset uint64
+	Epoch  string
+}
+
+func (c *Client) sendSubscribe(channel string, recover bool, streamPos streamPosition, token string, fn func(res protocol.SubscribeResult, err error)) error {
+	params := &protocol.SubscribeRequest{
+		Channel: channel,
+	}
+
+	if recover {
+		params.Recover = true
+		if streamPos.Seq > 0 || streamPos.Gen > 0 {
+			params.Seq = streamPos.Seq
+			params.Gen = streamPos.Gen
+		} else if streamPos.Offset > 0 {
+			params.Offset = streamPos.Offset
+		}
+		params.Epoch = streamPos.Epoch
+	}
+	if token != "" {
+		params.Token = token
+	}
+
+	paramsData, err := c.paramsEncoder.Encode(params)
+	if err != nil {
+		return err
+	}
+
+	cmd := &protocol.Command{
+		ID:     c.nextMsgID(),
+		Method: protocol.MethodTypeSubscribe,
+		Params: paramsData,
+	}
+	return c.sendAsync(cmd, func(reply protocol.Reply, err error) {
+		if err != nil {
+			fn(protocol.SubscribeResult{}, err)
+			return
+		}
+		if reply.Error != nil {
+			fn(protocol.SubscribeResult{}, reply.Error)
+			return
+		}
+		var res protocol.SubscribeResult
+		err = c.resultDecoder.Decode(reply.Result, &res)
+		if err != nil {
+			fn(protocol.SubscribeResult{}, err)
+			return
+		}
+		fn(res, nil)
+	})
+}
+
+func (c *Client) nextFutureID() uint64 {
+	return atomic.AddUint64(&c.futureID, 1)
+}
+
+type connectFuture struct {
+	fn      func(error)
+	closeCh chan struct{}
+}
+
+func newConnectFuture(fn func(error)) connectFuture {
+	return connectFuture{fn: fn, closeCh: make(chan struct{})}
+}
+
+// lock must be held outside.
+func (c *Client) resolveConnectFutures(err error) {
+	for _, fut := range c.connectFutures {
+		fut.fn(err)
+		close(fut.closeCh)
+	}
+	c.connectFutures = make(map[uint64]connectFuture)
+}
+
+func (c *Client) onConnect(fn func(err error)) {
+	c.mu.Lock()
+	if c.status == CONNECTED {
+		c.mu.Unlock()
+		fn(nil)
+	} else if c.status == DISCONNECTED {
+		c.mu.Unlock()
+		fn(ErrClientDisconnected)
+	} else if c.status == CLOSED {
+		c.mu.Unlock()
+		fn(ErrClientClosed)
+	} else {
+		defer c.mu.Unlock()
+		id := c.nextFutureID()
+		fut := newConnectFuture(fn)
+		c.connectFutures[id] = fut
+		go func() {
+			select {
+			case <-fut.closeCh:
+			case <-time.After(c.config.ReadTimeout):
+				c.mu.Lock()
+				defer c.mu.Unlock()
+				fut, ok := c.connectFutures[id]
+				if !ok {
+					return
+				}
+				delete(c.connectFutures, id)
+				fut.fn(ErrTimeout)
+			}
+		}()
+	}
+}
+
+// PublishResult contains the result of publish.
+type PublishResult struct{}
+
+// Publish data into channel.
+func (c *Client) Publish(channel string, data []byte) (PublishResult, error) {
+	resCh := make(chan PublishResult, 1)
+	errCh := make(chan error, 1)
+	c.publish(channel, data, func(result PublishResult, err error) {
+		resCh <- result
+		errCh <- err
+	})
+	return <-resCh, <-errCh
+}
+
+func (c *Client) publish(channel string, data []byte, fn func(PublishResult, error)) {
+	c.onConnect(func(err error) {
+		if err != nil {
+			fn(PublishResult{}, err)
+			return
+		}
+		c.sendPublish(channel, data, fn)
+	})
+}
+
+func (c *Client) sendPublish(channel string, data []byte, fn func(PublishResult, error)) {
+	params := &protocol.PublishRequest{
+		Channel: channel,
+		Data:    protocol.Raw(data),
+	}
+	paramsData, err := c.paramsEncoder.Encode(params)
+	if err != nil {
+		fn(PublishResult{}, err)
+		return
+	}
+	cmd := &protocol.Command{
+		ID:     c.nextMsgID(),
+		Method: protocol.MethodTypePublish,
+		Params: paramsData,
+	}
+	err = c.sendAsync(cmd, func(r protocol.Reply, err error) {
+		if err != nil {
+			fn(PublishResult{}, err)
+			return
+		}
+		if r.Error != nil {
+			fn(PublishResult{}, r.Error)
+			return
+		}
+		fn(PublishResult{}, nil)
+	})
+	if err != nil {
+		fn(PublishResult{}, err)
+	}
+}
+
+// HistoryResult contains the result of history op.
+type HistoryResult struct {
+	Publications []Publication
+}
+
+func (c *Client) history(channel string, fn func(HistoryResult, error)) {
+	c.onConnect(func(err error) {
+		if err != nil {
+			fn(HistoryResult{}, err)
+			return
+		}
+		c.sendHistory(channel, fn)
+	})
+}
+
+func (c *Client) sendHistory(channel string, fn func(HistoryResult, error)) {
+	params := &protocol.HistoryRequest{
+		Channel: channel,
+	}
+
+	paramsData, err := c.paramsEncoder.Encode(params)
+	if err != nil {
+		fn(HistoryResult{}, err)
+		return
+	}
+
+	cmd := &protocol.Command{
+		ID:     c.nextMsgID(),
+		Method: protocol.MethodTypeHistory,
+		Params: paramsData,
+	}
+	err = c.sendAsync(cmd, func(r protocol.Reply, err error) {
+		if err != nil {
+			fn(HistoryResult{}, err)
+			return
+		}
+		if r.Error != nil {
+			fn(HistoryResult{}, r.Error)
+			return
+		}
+		var res protocol.HistoryResult
+		err = c.resultDecoder.Decode(r.Result, &res)
+		if err != nil {
+			fn(HistoryResult{}, err)
+			return
+		}
+		pubs := make([]Publication, len(res.Publications))
+		for i, m := range res.Publications {
+			pubs[i] = pubFromProto(*m)
+		}
+		fn(HistoryResult{Publications: pubs}, nil)
+	})
+	if err != nil {
+		fn(HistoryResult{}, err)
+		return
+	}
+}
+
+// HistoryResult contains the result of presence op.
+type PresenceResult struct {
+	Presence map[string]ClientInfo
+}
+
+func (c *Client) presence(channel string, fn func(PresenceResult, error)) {
+	c.onConnect(func(err error) {
+		if err != nil {
+			fn(PresenceResult{}, err)
+			return
+		}
+		c.sendPresence(channel, fn)
+	})
+}
+
+func (c *Client) sendPresence(channel string, fn func(PresenceResult, error)) {
+	params := &protocol.PresenceRequest{
+		Channel: channel,
+	}
+
+	paramsData, err := c.paramsEncoder.Encode(params)
+	if err != nil {
+		fn(PresenceResult{}, err)
+		return
+	}
+
+	cmd := &protocol.Command{
+		ID:     c.nextMsgID(),
+		Method: protocol.MethodTypePresence,
+		Params: paramsData,
+	}
+	err = c.sendAsync(cmd, func(r protocol.Reply, err error) {
+		if err != nil {
+			fn(PresenceResult{}, err)
+			return
+		}
+		if r.Error != nil {
+			fn(PresenceResult{}, r.Error)
+			return
+		}
+		var res protocol.PresenceResult
+		err = c.resultDecoder.Decode(r.Result, &res)
+		if err != nil {
+			fn(PresenceResult{}, err)
+			return
+		}
+		p := make(map[string]ClientInfo)
+		for uid, info := range res.Presence {
+			p[uid] = infoFromProto(*info)
+		}
+		fn(PresenceResult{Presence: p}, nil)
+	})
+	if err != nil {
+		fn(PresenceResult{}, err)
+	}
+}
+
+// PresenceStats represents short presence information.
+type PresenceStats struct {
+	NumClients int
+	NumUsers   int
+}
+
+// PresenceStatsResult wraps presence stats.
+type PresenceStatsResult struct {
+	PresenceStats
+}
+
+func (c *Client) presenceStats(channel string, fn func(PresenceStatsResult, error)) {
+	c.onConnect(func(err error) {
+		if err != nil {
+			fn(PresenceStatsResult{}, err)
+			return
+		}
+		c.sendPresenceStats(channel, fn)
+	})
+}
+
+func (c *Client) sendPresenceStats(channel string, fn func(PresenceStatsResult, error)) {
+	params := &protocol.PresenceStatsRequest{
+		Channel: channel,
+	}
+	paramsData, err := c.paramsEncoder.Encode(params)
+	if err != nil {
+		fn(PresenceStatsResult{}, err)
+		return
+	}
+
+	cmd := &protocol.Command{
+		ID:     c.nextMsgID(),
+		Method: protocol.MethodTypePresenceStats,
+		Params: paramsData,
+	}
+	err = c.sendAsync(cmd, func(r protocol.Reply, err error) {
+		if err != nil {
+			fn(PresenceStatsResult{}, err)
+			return
+		}
+		if r.Error != nil {
+			fn(PresenceStatsResult{}, r.Error)
+			return
+		}
+		var res protocol.PresenceStatsResult
+		err = c.resultDecoder.Decode(r.Result, &res)
+		if err != nil {
+			fn(PresenceStatsResult{}, err)
+			return
+		}
+		fn(PresenceStatsResult{PresenceStats{
+			NumClients: int(res.NumClients),
+			NumUsers:   int(res.NumUsers),
+		}}, nil)
+	})
+	if err != nil {
+		fn(PresenceStatsResult{}, err)
+		return
+	}
+}
+
+type UnsubscribeResult struct{}
+
+func (c *Client) unsubscribe(channel string, fn func(UnsubscribeResult, error)) {
+	if !c.subscribed(channel) {
+		return
+	}
+	c.sendUnsubscribe(channel, fn)
+}
+
+func (c *Client) sendUnsubscribe(channel string, fn func(UnsubscribeResult, error)) {
+	params := &protocol.UnsubscribeRequest{
+		Channel: channel,
+	}
+
+	paramsData, err := c.paramsEncoder.Encode(params)
+	if err != nil {
+		fn(UnsubscribeResult{}, err)
+		return
+	}
+
+	cmd := &protocol.Command{
+		ID:     c.nextMsgID(),
+		Method: protocol.MethodTypeUnsubscribe,
+		Params: paramsData,
+	}
+	err = c.sendAsync(cmd, func(r protocol.Reply, err error) {
+		if err != nil {
+			fn(UnsubscribeResult{}, err)
+			return
+		}
+		if r.Error != nil {
+			fn(UnsubscribeResult{}, r.Error)
+			return
+		}
+		var res protocol.UnsubscribeResult
+		err = c.resultDecoder.Decode(r.Result, &res)
+		if err != nil {
+			fn(UnsubscribeResult{}, err)
+			return
+		}
+		fn(UnsubscribeResult{}, nil)
+	})
+	if err != nil {
+		fn(UnsubscribeResult{}, err)
+	}
+}
+
+func (c *Client) sendPing(fn func(error)) {
+	cmd := &protocol.Command{
+		ID:     c.nextMsgID(),
+		Method: protocol.MethodTypePing,
+	}
+	_ = c.sendAsync(cmd, func(_ protocol.Reply, err error) {
+		fn(err)
+	})
+}
+
+func (c *Client) sendAsync(cmd *protocol.Command, cb func(protocol.Reply, error)) error {
+	c.addRequest(cmd.ID, cb)
+
+	err := c.send(cmd)
+	if err != nil {
+		return err
+	}
+	go func() {
+		defer c.removeRequest(cmd.ID)
+		select {
+		case <-time.After(c.config.ReadTimeout):
+			c.requestsMu.RLock()
+			req, ok := c.requests[cmd.ID]
+			c.requestsMu.RUnlock()
+			if !ok {
+				return
+			}
+			req.cb(protocol.Reply{}, ErrTimeout)
+		case <-c.closeCh:
+			c.requestsMu.RLock()
+			req, ok := c.requests[cmd.ID]
+			c.requestsMu.RUnlock()
+			if !ok {
+				return
+			}
+			req.cb(protocol.Reply{}, ErrClientClosed)
+		}
+	}()
+	return nil
+}
+
+func (c *Client) send(cmd *protocol.Command) error {
+	transport := c.transport
+	if transport == nil {
+		return ErrClientDisconnected
+	}
+	err := transport.Write(cmd, c.config.WriteTimeout)
+	if err != nil {
+		go c.handleDisconnect(&disconnect{Reason: "write error", Reconnect: true})
+		return io.EOF
+	}
+	return nil
+}
+
+type request struct {
+	cb func(protocol.Reply, error)
+}
+
+func (c *Client) addRequest(id uint32, cb func(protocol.Reply, error)) {
+	c.requestsMu.Lock()
+	defer c.requestsMu.Unlock()
+	c.requests[id] = request{cb}
+}
+
+func (c *Client) removeRequest(id uint32) {
+	c.requestsMu.Lock()
+	defer c.requestsMu.Unlock()
+	delete(c.requests, id)
+}
diff --git a/vendor/github.com/centrifugal/centrifuge-go/config.go b/vendor/github.com/centrifugal/centrifuge-go/config.go
new file mode 100644
index 0000000..4d390dd
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/config.go
@@ -0,0 +1,66 @@
+package centrifuge
+
+import (
+	"context"
+	"crypto/tls"
+	"net"
+	"net/http"
+	"time"
+)
+
+const (
+	// DefaultHandshakeTimeout ...
+	DefaultHandshakeTimeout = time.Second
+	// DefaultReadTimeout ...
+	DefaultReadTimeout = 5 * time.Second
+	// DefaultWriteTimeout ...
+	DefaultWriteTimeout = time.Second
+	// DefaultPingInterval ...
+	DefaultPingInterval = 25 * time.Second
+	// DefaultPrivateChannelPrefix ...
+	DefaultPrivateChannelPrefix = "$"
+)
+
+// Config contains various client options.
+type Config struct {
+	// NetDialContext specifies the dial function for creating TCP connections. If
+	// NetDialContext is nil, net.DialContext is used.
+	NetDialContext func(ctx context.Context, network, addr string) (net.Conn, error)
+
+	// PrivateChannelPrefix is private channel prefix.
+	PrivateChannelPrefix string
+	// ReadTimeout is how long to wait read operations to complete.
+	ReadTimeout time.Duration
+	// WriteTimeout is Websocket write timeout.
+	WriteTimeout time.Duration
+	// PingInterval is how often to send ping commands to server.
+	PingInterval time.Duration
+	// HandshakeTimeout specifies the duration for the handshake to complete.
+	HandshakeTimeout time.Duration
+	// TLSConfig specifies the TLS configuration to use with tls.Client.
+	// If nil, the default configuration is used.
+	TLSConfig *tls.Config
+	// EnableCompression specifies if the client should attempt to negotiate
+	// per message compression (RFC 7692). Setting this value to true does not
+	// guarantee that compression will be supported. Currently only "no context
+	// takeover" modes are supported.
+	EnableCompression bool
+	// CookieJar specifies the cookie jar.
+	// If CookieJar is nil, cookies are not sent in requests and ignored
+	// in responses.
+	CookieJar http.CookieJar
+	// Header specifies custom HTTP Header to send.
+	Header http.Header
+}
+
+// DefaultConfig returns Config with default options.
+func DefaultConfig() Config {
+	return Config{
+		PingInterval:         DefaultPingInterval,
+		ReadTimeout:          DefaultReadTimeout,
+		WriteTimeout:         DefaultWriteTimeout,
+		HandshakeTimeout:     DefaultHandshakeTimeout,
+		PrivateChannelPrefix: DefaultPrivateChannelPrefix,
+		Header:               http.Header{},
+	}
+}
diff --git a/vendor/github.com/centrifugal/centrifuge-go/errors.go b/vendor/github.com/centrifugal/centrifuge-go/errors.go
new file mode 100644
index 0000000..18c0c3a
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/errors.go
@@ -0,0 +1,21 @@
+package centrifuge
+
+import "errors"
+
+var (
+	// ErrTimeout returned if operation timed out.
+	ErrTimeout = errors.New("timeout")
+	// ErrClientClosed can be returned if client already closed.
+	ErrClientClosed = errors.New("client closed")
+	// ErrClientDisconnected can be returned if client goes to
+	// disconnected state while operation in progress.
+	ErrClientDisconnected = errors.New("client disconnected")
+	// ErrReconnectFailed returned when reconnect to server failed (never
+	// happen by default since client keeps reconnecting forever).
+	ErrReconnectFailed = errors.New("reconnect failed")
+	// ErrDuplicateSubscription returned if subscription to the same channel
+	// already registered in current client instance. This is due to the fact
+	// that server does not allow subscribing to the same channel twice for
+	// the same connection.
+	ErrDuplicateSubscription = errors.New("duplicate subscription")
+)
diff --git a/vendor/github.com/centrifugal/centrifuge-go/events.go b/vendor/github.com/centrifugal/centrifuge-go/events.go
new file mode 100644
index 0000000..5185b54
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/events.go
@@ -0,0 +1,197 @@
+package centrifuge
+
+// PrivateSubEvent contains info required to create PrivateSign when client
+// wants to subscribe on private channel.
+type PrivateSubEvent struct {
+	ClientID string
+	Channel  string
+}
+
+// ServerPublishEvent has info about received channel Publication.
+type ServerPublishEvent struct {
+	Channel string
+	Publication
+}
+
+type ServerSubscribeEvent struct {
+	Channel      string
+	Resubscribed bool
+	Recovered    bool
+}
+
+// ServerJoinEvent has info about user who left channel.
+type ServerJoinEvent struct {
+	Channel string
+	ClientInfo
+}
+
+// ServerLeaveEvent has info about user who joined channel.
+type ServerLeaveEvent struct {
+	Channel string
+	ClientInfo
+}
+
+// ServerUnsubscribeEvent is an event passed to unsubscribe event handler.
+type ServerUnsubscribeEvent struct {
+	Channel string
+}
+
+// ConnectEvent is a connect event context passed to OnConnect callback.
+type ConnectEvent struct {
+	ClientID string
+	Version  string
+	Data     []byte
+}
+
+// DisconnectEvent is a disconnect event context passed to OnDisconnect callback.
+type DisconnectEvent struct {
+	Reason    string
+	Reconnect bool
+}
+
+// ErrorEvent is an error event context passed to OnError callback.
+type ErrorEvent struct {
+	// TODO: return error type here instead of string
+	// so user code could distinguish various types of possible errors?
+	Message string
+}
+
+// MessageEvent is an event for async message from server to client.
+type MessageEvent struct {
+	Data []byte
+}
+
+// ConnectHandler is an interface describing how to handle connect event.
+type ConnectHandler interface {
+	OnConnect(*Client, ConnectEvent)
+}
+
+// DisconnectHandler is an interface describing how to handle disconnect event.
+type DisconnectHandler interface {
+	OnDisconnect(*Client, DisconnectEvent)
+}
+
+// MessageHandler is an interface describing how to handle async message from server.
+type MessageHandler interface {
+	OnMessage(*Client, MessageEvent)
+}
+
+// ServerPublishHandler is an interface describing how to handle Publication from
+// server-side subscriptions.
+type ServerPublishHandler interface {
+	OnServerPublish(*Client, ServerPublishEvent)
+}
+
+// ServerSubscribeHandler is an interface describing how to handle subscribe events from
+// server-side subscriptions.
+type ServerSubscribeHandler interface {
+	OnServerSubscribe(*Client, ServerSubscribeEvent)
+}
+
+// ServerUnsubscribeHandler is an interface describing how to handle unsubscribe events from
+// server-side subscriptions.
+type ServerUnsubscribeHandler interface {
+	OnServerUnsubscribe(*Client, ServerUnsubscribeEvent)
+}
+
+// ServerJoinHandler is an interface describing how to handle Join events from
+// server-side subscriptions.
+type ServerJoinHandler interface {
+	OnServerJoin(*Client, ServerJoinEvent)
+}
+
+// ServerLeaveHandler is an interface describing how to handle Leave events from
+// server-side subscriptions.
+type ServerLeaveHandler interface {
+	OnServerLeave(*Client, ServerLeaveEvent)
+}
+
+// PrivateSubHandler is an interface describing how to handle private subscription request.
+type PrivateSubHandler interface {
+	OnPrivateSub(*Client, PrivateSubEvent) (string, error)
+}
+
+// RefreshHandler is an interface describing how to handle token refresh event.
+type RefreshHandler interface {
+	OnRefresh(*Client) (string, error)
+}
+
+// ErrorHandler is an interface describing how to handle error event.
+type ErrorHandler interface {
+	OnError(*Client, ErrorEvent)
+}
+
+// eventHub has all event handlers for client.
+type eventHub struct {
+	onConnect           ConnectHandler
+	onDisconnect        DisconnectHandler
+	onPrivateSub        PrivateSubHandler
+	onRefresh           RefreshHandler
+	onError             ErrorHandler
+	onMessage           MessageHandler
+	onServerSubscribe   ServerSubscribeHandler
+	onServerPublish     ServerPublishHandler
+	onServerJoin        ServerJoinHandler
+	onServerLeave       ServerLeaveHandler
+	onServerUnsubscribe ServerUnsubscribeHandler
+}
+
+// newEventHub initializes new eventHub.
+func newEventHub() *eventHub {
+	return &eventHub{}
+}
+
+// OnConnect is a function to handle connect event.
+func (c *Client) OnConnect(handler ConnectHandler) {
+	c.events.onConnect = handler
+}
+
+// OnServerPublish sets function to handle Publications from server-side subscriptions.
+func (c *Client) OnServerPublish(handler ServerPublishHandler) {
+	c.events.onServerPublish = handler
+}
+
+// OnServerSubscribe sets function to handle server-side subscription subscribe events.
+func (c *Client) OnServerSubscribe(handler ServerSubscribeHandler) {
+	c.events.onServerSubscribe = handler
+}
+
+// OnServerUnsubscribe sets function to handle unsubscribe from server-side subscriptions.
+func (c *Client) OnServerUnsubscribe(handler ServerUnsubscribeHandler) {
+	c.events.onServerUnsubscribe = handler
+}
+
+// OnServerJoin sets function to handle Join event from server-side subscriptions.
+func (c *Client) OnServerJoin(handler ServerJoinHandler) {
+	c.events.onServerJoin = handler
+}
+
+// OnServerLeave sets function to handle Leave event from server-side subscriptions.
+func (c *Client) OnServerLeave(handler ServerLeaveHandler) {
+	c.events.onServerLeave = handler
+}
+
+// OnDisconnect is a function to handle disconnect event.
+func (c *Client) OnDisconnect(handler DisconnectHandler) {
+	c.events.onDisconnect = handler
+}
+
+// OnPrivateSub needed to handle private channel subscriptions.
+func (c *Client) OnPrivateSub(handler PrivateSubHandler) {
+	c.events.onPrivateSub = handler
+}
+
+// OnRefresh handles refresh event when client's credentials expired and must be refreshed.
+func (c *Client) OnRefresh(handler RefreshHandler) {
+	c.events.onRefresh = handler
+}
+
+// OnError is a function that will receive unhandled errors for logging.
+func (c *Client) OnError(handler ErrorHandler) {
+	c.events.onError = handler
+}
+
+// OnMessage allows to process async message from server to client.
+func (c *Client) OnMessage(handler MessageHandler) {
+	c.events.onMessage = handler
+}
diff --git a/vendor/github.com/centrifugal/centrifuge-go/go.mod b/vendor/github.com/centrifugal/centrifuge-go/go.mod
new file mode 100644
index 0000000..cccfcb3
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/go.mod
@@ -0,0 +1,9 @@
+module github.com/centrifugal/centrifuge-go
+
+go 1.13
+
+require (
+	github.com/centrifugal/protocol v0.3.4
+	github.com/gorilla/websocket v1.4.2
+	github.com/jpillora/backoff v1.0.0
+)
diff --git a/vendor/github.com/centrifugal/centrifuge-go/go.sum b/vendor/github.com/centrifugal/centrifuge-go/go.sum
new file mode 100644
index 0000000..1bdcd99
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/go.sum
@@ -0,0 +1,11 @@
+github.com/centrifugal/protocol v0.3.4 h1:9q22iSp4CQOdQahfopvfmWWxDbj1Lo7ERG2j56mAxkE=
+github.com/centrifugal/protocol v0.3.4/go.mod h1:2YbBCaDwQHl37ErRdMrKSj18X2yVvpkQYtSX6aVbe5A=
+github.com/gogo/protobuf v1.3.1 h1:DqDEcV5aeaTmdFBePNpYsp3FlcVH/2ISVVM9Qf8PSls=
+github.com/gogo/protobuf v1.3.1/go.mod h1:SlYgWuQ5SjCEi6WLHjHCa1yvBfUnHcTbrrZtXPKa29o=
+github.com/gorilla/websocket v1.4.2 h1:+/TMaTYc4QFitKJxsQ7Yye35DkWvkdLcvGKqM+x0Ufc=
+github.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
+github.com/jpillora/backoff v1.0.0 h1:uvFg412JmmHBHw7iwprIxkPMI+sGQ4kzOWsMeHnm2EA=
+github.com/jpillora/backoff v1.0.0/go.mod h1:J/6gKK9jxlEcS3zixgDgUAsiuZ7yrSoa/FX5e0EB2j4=
+github.com/kisielk/errcheck v1.2.0/go.mod h1:/BMXB+zMLi60iA8Vv6Ksmxu/1UDYcXs4uQLJ+jE2L00=
+github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
+golang.org/x/tools v0.0.0-20181030221726-6c7e314b6563/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
diff --git a/vendor/github.com/centrifugal/centrifuge-go/protocol.go b/vendor/github.com/centrifugal/centrifuge-go/protocol.go
new file mode 100644
index 0000000..5c6944f
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/protocol.go
@@ -0,0 +1,96 @@
+package centrifuge
+
+import "github.com/centrifugal/protocol"
+
+// Publication is a data sent to channel.
+type Publication struct {
+	// Offset is an incremental position number inside history stream.
+	// Zero value means that channel does not maintain Publication stream.
+	Offset uint64
+	// Data published to channel.
+	Data []byte
+	// Info is an optional information about client connection published
+	// this data to channel.
+	Info *ClientInfo
+}
+
+// ClientInfo contains information about client connection.
+type ClientInfo struct {
+	// Client is a client unique id.
+	Client string
+	// User is an ID of authenticated user. Zero value means anonymous user.
+	User string
+	// ConnInfo is an additional information about connection.
+	ConnInfo []byte
+	// ChanInfo is an additional information about connection in context of
+	// channel subscription.
+	ChanInfo []byte
+}
+
+func newPushEncoder(enc protocol.Type) protocol.PushEncoder {
+	if enc == protocol.TypeJSON {
+		return protocol.NewJSONPushEncoder()
+	}
+	return protocol.NewProtobufPushEncoder()
+}
+
+func newPushDecoder(enc protocol.Type) protocol.PushDecoder {
+	if enc == protocol.TypeJSON {
+		return protocol.NewJSONPushDecoder()
+	}
+	return protocol.NewProtobufPushDecoder()
+}
+
+func newReplyDecoder(enc protocol.Type, data []byte) protocol.ReplyDecoder {
+	if enc == protocol.TypeJSON {
+		return protocol.NewJSONReplyDecoder(data)
+	}
+	return protocol.NewProtobufReplyDecoder(data)
+}
+
+func newResultDecoder(enc protocol.Type) protocol.ResultDecoder {
+	if enc == protocol.TypeJSON {
+		return protocol.NewJSONResultDecoder()
+	}
+	return protocol.NewProtobufResultDecoder()
+}
+
+func newParamsEncoder(enc protocol.Type) protocol.ParamsEncoder {
+	if enc == protocol.TypeJSON {
+		return protocol.NewJSONParamsEncoder()
+	}
+	return protocol.NewProtobufParamsEncoder()
+}
+
+func newCommandEncoder(enc protocol.Type) protocol.CommandEncoder {
+	if enc == protocol.TypeJSON {
+		return protocol.NewJSONCommandEncoder()
+	}
+	return protocol.NewProtobufCommandEncoder()
+}
+
+func infoFromProto(v protocol.ClientInfo) ClientInfo {
+	info := ClientInfo{
+		Client: v.GetClient(),
+		User:   v.GetUser(),
+	}
+	if len(v.ConnInfo) > 0 {
+		info.ConnInfo = v.ConnInfo
+	}
+	if len(v.ChanInfo) > 0 {
+		info.ChanInfo = v.ChanInfo
+	}
+	return info
+}
+
+func pubFromProto(pub protocol.Publication) Publication {
+	p := Publication{
+		Offset: pub.GetOffset(),
+		Data:   pub.Data,
+	}
+	if pub.GetInfo() != nil {
+		info := infoFromProto(*pub.GetInfo())
+		p.Info = &info
+	}
+	return p
+}
diff --git a/vendor/github.com/centrifugal/centrifuge-go/queue.go b/vendor/github.com/centrifugal/centrifuge-go/queue.go
new file mode 100644
index 0000000..9280dc2
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/queue.go
@@ -0,0 +1,79 @@
+package centrifuge
+
+import "sync"
+
+// cbQueue allows to process callbacks in separate goroutine with
+// preserved order.
+// This queue implementation is a slightly modified code borrowed from
+// https://github.com/nats-io/nats.go client released under Apache 2.0
+// license: see https://github.com/nats-io/nats.go/blob/master/LICENSE.
+type cbQueue struct {
+	mu   sync.Mutex
+	cond *sync.Cond
+	head *asyncCB
+	tail *asyncCB
+}
+
+type asyncCB struct {
+	fn   func()
+	next *asyncCB
+}
+
+// dispatch is responsible for calling async callbacks. Should be run
+// in separate goroutine.
+func (q *cbQueue) dispatch() {
+	for {
+		q.mu.Lock()
+		// Protect for spurious wake-ups. We should get out of the
+		// wait only if there is an element to pop from the list.
+		for q.head == nil {
+			q.cond.Wait()
+		}
+		curr := q.head
+		q.head = curr.next
+		if curr == q.tail {
+			q.tail = nil
+		}
+		q.mu.Unlock()
+
+		// This signals that the dispatcher has been closed and all
+		// previous callbacks have been dispatched.
+		if curr.fn == nil {
+			return
+		}
+		curr.fn()
+	}
+}
+
+// Push adds the given function to the tail of the list and
+// signals the dispatcher.
+func (q *cbQueue) push(f func()) {
+	q.pushOrClose(f, false)
+}
+
+// Close signals that async queue must be closed.
+func (q *cbQueue) close() {
+	q.pushOrClose(nil, true)
+}
+
+func (q *cbQueue) pushOrClose(f func(), close bool) {
+	q.mu.Lock()
+	defer q.mu.Unlock()
+	// Make sure that library is not calling push with nil function,
+	// since this is used to notify the dispatcher that it must stop.
+	if !close && f == nil {
+		panic("pushing a nil callback with false close")
+	}
+	cb := &asyncCB{fn: f}
+	if q.tail != nil {
+		q.tail.next = cb
+	} else {
+		q.head = cb
+	}
+	q.tail = cb
+	if close {
+		q.cond.Broadcast()
+	} else {
+		q.cond.Signal()
+	}
+}
diff --git a/vendor/github.com/centrifugal/centrifuge-go/reconnect.go b/vendor/github.com/centrifugal/centrifuge-go/reconnect.go
new file mode 100644
index 0000000..becae00
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/reconnect.go
@@ -0,0 +1,45 @@
+package centrifuge
+
+import (
+	"time"
+
+	"github.com/jpillora/backoff"
+)
+
+type reconnectStrategy interface {
+	timeBeforeNextAttempt(attempt int) (time.Duration, error)
+}
+
+type backoffReconnect struct {
+	// NumReconnect is maximum number of reconnect attempts, 0 means reconnect forever.
+	NumReconnect int
+	// Factor is the multiplying factor for each increment step.
+	Factor float64
+	// Jitter eases contention by randomizing backoff steps.
+	Jitter bool
+	// MinMilliseconds is a minimum value of the reconnect interval.
+	MinMilliseconds int
+	// MaxMilliseconds is a maximum value of the reconnect interval.
+	MaxMilliseconds int
+}
+
+var defaultBackoffReconnect = &backoffReconnect{
+	NumReconnect:    0,
+	MinMilliseconds: 100,
+	MaxMilliseconds: 20 * 1000,
+	Factor:          4,
+	Jitter:          true,
+}
+
+func (r *backoffReconnect) timeBeforeNextAttempt(attempt int) (time.Duration, error) {
+	b := &backoff.Backoff{
+		Min:    time.Duration(r.MinMilliseconds) * time.Millisecond,
+		Max:    time.Duration(r.MaxMilliseconds) * time.Millisecond,
+		Factor: r.Factor,
+		Jitter: r.Jitter,
+	}
+	if r.NumReconnect > 0 && attempt >= r.NumReconnect {
+		return 0, ErrReconnectFailed
+	}
+	return b.ForAttempt(float64(attempt)), nil
+}
diff --git a/vendor/github.com/centrifugal/centrifuge-go/subscription.go b/vendor/github.com/centrifugal/centrifuge-go/subscription.go
new file mode 100644
index 0000000..9c0839b
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/subscription.go
@@ -0,0 +1,548 @@
+package centrifuge
+
+import (
+	"fmt"
+	"sync"
+	"sync/atomic"
+	"time"
+
+	"github.com/centrifugal/protocol"
+)
+
+// SubscribeSuccessEvent is a subscribe success event context passed
+// to event callback.
+type SubscribeSuccessEvent struct {
+	Resubscribed bool
+	Recovered    bool
+}
+
+// SubscribeErrorEvent is a subscribe error event context passed to
+// event callback.
+type SubscribeErrorEvent struct {
+	Error string
+}
+
+// UnsubscribeEvent is an event passed to unsubscribe event handler.
+type UnsubscribeEvent struct{}
+
+// LeaveEvent has info about user who left channel.
+type LeaveEvent struct {
+	ClientInfo
+}
+
+// JoinEvent has info about user who joined channel.
+type JoinEvent struct {
+	ClientInfo
+}
+
+// PublishEvent has info about received channel Publication.
+type PublishEvent struct {
+	Publication
+}
+
+// PublishHandler is a function to handle messages published in
+// channels.
+type PublishHandler interface {
+	OnPublish(*Subscription, PublishEvent)
+}
+
+// JoinHandler is a function to handle join messages.
+type JoinHandler interface {
+	OnJoin(*Subscription, JoinEvent)
+}
+
+// LeaveHandler is a function to handle leave messages.
+type LeaveHandler interface {
+	OnLeave(*Subscription, LeaveEvent)
+}
+
+// UnsubscribeHandler is a function to handle unsubscribe event.
+type UnsubscribeHandler interface {
+	OnUnsubscribe(*Subscription, UnsubscribeEvent)
+}
+
+// SubscribeSuccessHandler is a function to handle subscribe success event.
+type SubscribeSuccessHandler interface {
+	OnSubscribeSuccess(*Subscription, SubscribeSuccessEvent)
+}
+
+// SubscribeErrorHandler is a function to handle subscribe error event.
+type SubscribeErrorHandler interface {
+	OnSubscribeError(*Subscription, SubscribeErrorEvent)
+}
+
+// subscriptionEventHub contains callback functions that will be called when
+// corresponding event happens with subscription to channel.
+type subscriptionEventHub struct {
+	onPublish          PublishHandler
+	onJoin             JoinHandler
+	onLeave            LeaveHandler
+	onUnsubscribe      UnsubscribeHandler
+	onSubscribeSuccess SubscribeSuccessHandler
+	onSubscribeError   SubscribeErrorHandler
+}
+
+// newSubscriptionEventHub initializes new subscriptionEventHub.
+func newSubscriptionEventHub() *subscriptionEventHub {
+	return &subscriptionEventHub{}
+}
+
+// OnPublish allows to set PublishHandler to SubEventHandler.
+func (s *Subscription) OnPublish(handler PublishHandler) {
+	s.events.onPublish = handler
+}
+
+// OnJoin allows to set JoinHandler to SubEventHandler.
+func (s *Subscription) OnJoin(handler JoinHandler) {
+	s.events.onJoin = handler
+}
+
+// OnLeave allows to set LeaveHandler to SubEventHandler.
+func (s *Subscription) OnLeave(handler LeaveHandler) {
+	s.events.onLeave = handler
+}
+
+// OnUnsubscribe allows to set UnsubscribeHandler to SubEventHandler.
+func (s *Subscription) OnUnsubscribe(handler UnsubscribeHandler) {
+	s.events.onUnsubscribe = handler
+}
+
+// OnSubscribeSuccess allows to set SubscribeSuccessHandler to SubEventHandler.
+func (s *Subscription) OnSubscribeSuccess(handler SubscribeSuccessHandler) {
+	s.events.onSubscribeSuccess = handler
+}
+
+// OnSubscribeError allows to set SubscribeErrorHandler to SubEventHandler.
+func (s *Subscription) OnSubscribeError(handler SubscribeErrorHandler) {
+	s.events.onSubscribeError = handler
+}
+
+// Describe different states of Subscription.
+const (
+	UNSUBSCRIBED = iota
+	SUBSCRIBING
+	SUBSCRIBED
+	SUBERROR
+)
+
+// Subscription represents client subscription to channel.
+type Subscription struct {
+	mu              sync.Mutex
+	channel         string
+	centrifuge      *Client
+	subCloseCh      chan struct{}
+	status          int
+	events          *subscriptionEventHub
+	lastSeq         uint32
+	lastGen         uint32
+	lastOffset      uint64
+	lastEpoch       string
+	recover         bool
+	err             error
+	needResubscribe bool
+	subFutures      map[uint64]subFuture
+	futureID        uint64
+}
+
+type subFuture struct {
+	fn      func(error)
+	closeCh chan struct{}
+}
+
+func newSubFuture(fn func(error)) subFuture {
+	return subFuture{fn: fn, closeCh: make(chan struct{})}
+}
+
+func (c *Client) newSubscription(channel string) *Subscription {
+	s := &Subscription{
+		centrifuge:      c,
+		channel:         channel,
+		subCloseCh:      make(chan struct{}),
+		events:          newSubscriptionEventHub(),
+		subFutures:      make(map[uint64]subFuture),
+		needResubscribe: false,
+	}
+	return s
+}
+
+// Channel returns subscription channel.
+func (s *Subscription) Channel() string {
+	return s.channel
+}
+
+func (s *Subscription) nextFutureID() uint64 {
+	return atomic.AddUint64(&s.futureID, 1)
+}
+
+// Sub.mu lock must be held outside.
+func (s *Subscription) resolveSubFutures(err error) {
+	for _, fut := range s.subFutures {
+		fut.fn(err)
+		close(fut.closeCh)
+	}
+	s.subFutures = make(map[uint64]subFuture)
+}
+
+func (s *Subscription) removeSubFuture(id uint64) {
+	s.mu.Lock()
+	delete(s.subFutures, id)
+	s.mu.Unlock()
+}
+
+// Publish allows to publish data to channel.
+func (s *Subscription) Publish(data []byte) (PublishResult, error) {
+	resCh := make(chan PublishResult, 1)
+	errCh := make(chan error, 1)
+	s.publish(data, func(result PublishResult, err error) {
+		resCh <- result
+		errCh <- err
+	})
+	return <-resCh, <-errCh
+}
+
+// History allows to extract channel history.
+func (s *Subscription) History() (HistoryResult, error) {
+	resCh := make(chan HistoryResult, 1)
+	errCh := make(chan error, 1)
+	s.history(func(result HistoryResult, err error) {
+		resCh <- result
+		errCh <- err
+	})
+	return <-resCh, <-errCh
+}
+
+// Presence allows to extract channel history.
+func (s *Subscription) Presence() (PresenceResult, error) {
+	resCh := make(chan PresenceResult, 1)
+	errCh := make(chan error, 1)
+	s.presence(func(result PresenceResult, err error) {
+		resCh <- result
+		errCh <- err
+	})
+	return <-resCh, <-errCh
+}
+
+// PresenceStats allows to extract channel presence stats.
+func (s *Subscription) PresenceStats() (PresenceStatsResult, error) {
+	resCh := make(chan PresenceStatsResult, 1)
+	errCh := make(chan error, 1)
+	s.presenceStats(func(result PresenceStatsResult, err error) {
+		resCh <- result
+		errCh <- err
+	})
+	return <-resCh, <-errCh
+}
+
+func (s *Subscription) onSubscribe(fn func(err error)) {
+	s.mu.Lock()
+	defer s.mu.Unlock()
+	if s.status == SUBSCRIBED {
+		go fn(nil)
+	} else if s.status == SUBERROR {
+		go fn(s.err)
+	} else {
+		id := s.nextFutureID()
+		fut := newSubFuture(fn)
+		s.subFutures[id] = fut
+		go func() {
+			select {
+			case <-fut.closeCh:
+			case <-time.After(s.centrifuge.config.ReadTimeout):
+				s.mu.Lock()
+				defer s.mu.Unlock()
+				fut, ok := s.subFutures[id]
+				if !ok {
+					return
+				}
+				delete(s.subFutures, id)
+				fut.fn(ErrTimeout)
+			}
+		}()
+	}
+}
+
+func (s *Subscription) publish(data []byte, fn func(PublishResult, error)) {
+	s.onSubscribe(func(err error) {
+		if err != nil {
+			fn(PublishResult{}, err)
+			return
+		}
+		s.centrifuge.publish(s.channel, data, fn)
+	})
+}
+
+func (s *Subscription) history(fn func(HistoryResult, error)) {
+	s.onSubscribe(func(err error) {
+		if err != nil {
+			fn(HistoryResult{}, err)
+			return
+		}
+		s.centrifuge.history(s.channel, fn)
+	})
+}
+
+func (s *Subscription) presence(fn func(PresenceResult, error)) {
+	s.onSubscribe(func(err error) {
+		if err != nil {
+			fn(PresenceResult{}, err)
+			return
+		}
+		s.centrifuge.presence(s.channel, fn)
+	})
+}
+
+func (s *Subscription) presenceStats(fn func(PresenceStatsResult, error)) {
+	s.onSubscribe(func(err error) {
+		if err != nil {
+			fn(PresenceStatsResult{}, err)
+			return
+		}
+		s.centrifuge.presenceStats(s.channel, fn)
+	})
+}
+
+// Unsubscribe allows to unsubscribe from channel.
+func (s *Subscription) Unsubscribe() error {
+	s.triggerOnUnsubscribe(false, false)
+	s.centrifuge.unsubscribe(s.channel, func(result UnsubscribeResult, err error) {})
+	return nil
+}
+
+// Subscribe allows to subscribe again after unsubscribing.
+func (s *Subscription) Subscribe() error {
+	s.mu.Lock()
+	s.needResubscribe = true
+	s.mu.Unlock()
+	if !s.centrifuge.connected() {
+		return nil
+	}
+	return s.resubscribe(false, s.centrifuge.clientID())
+}
+
+func (s *Subscription) triggerOnUnsubscribe(needResubscribe bool, needRecover bool) {
+	s.mu.Lock()
+	if s.status != SUBSCRIBED {
+		s.status = UNSUBSCRIBED
+		s.mu.Unlock()
+		return
+	}
+	s.needResubscribe = needResubscribe
+	s.recover = needRecover
+	s.status = UNSUBSCRIBED
+	s.mu.Unlock()
+	if s.events != nil && s.events.onUnsubscribe != nil {
+		handler := s.events.onUnsubscribe
+		s.centrifuge.runHandler(func() {
+			handler.OnUnsubscribe(s, UnsubscribeEvent{})
+		})
+	}
+}
+
+func (s *Subscription) subscribeSuccess(isResubscribe bool, res protocol.SubscribeResult) {
+	s.mu.Lock()
+	if s.status != SUBSCRIBING {
+		s.mu.Unlock()
+		return
+	}
+	closeCh := make(chan struct{})
+	s.subCloseCh = closeCh
+	s.runSubRefresh(res.TTL, closeCh)
+	s.status = SUBSCRIBED
+	s.resolveSubFutures(nil)
+	s.mu.Unlock()
+	if s.events != nil && s.events.onSubscribeSuccess != nil {
+		handler := s.events.onSubscribeSuccess
+		ev := SubscribeSuccessEvent{Resubscribed: isResubscribe, Recovered: res.Recovered}
+		s.centrifuge.runHandler(func() {
+			handler.OnSubscribeSuccess(s, ev)
+		})
+	}
+	s.processRecover(res)
+}
+
+func (s *Subscription) subscribeError(err error) {
+	s.mu.Lock()
+	if s.status != SUBSCRIBING {
+		s.mu.Unlock()
+		return
+	}
+	if err == ErrTimeout {
+		s.status = UNSUBSCRIBED
+		s.mu.Unlock()
+		go s.centrifuge.handleDisconnect(&disconnect{"subscribe timeout", true})
+		return
+	}
+	s.err = err
+	s.status = SUBERROR
+	s.resolveSubFutures(err)
+	s.mu.Unlock()
+	if s.events != nil && s.events.onSubscribeError != nil {
+		handler := s.events.onSubscribeError
+		s.centrifuge.runHandler(func() {
+			handler.OnSubscribeError(s, SubscribeErrorEvent{Error: err.Error()})
+		})
+	}
+}
+
+func (s *Subscription) handlePublication(pub protocol.Publication) {
+	var handler PublishHandler
+	if s.events != nil && s.events.onPublish != nil {
+		handler = s.events.onPublish
+	}
+	if handler != nil {
+		s.centrifuge.runHandler(func() {
+			handler.OnPublish(s, PublishEvent{Publication: pubFromProto(pub)})
+			s.mu.Lock()
+			if pub.Seq > 0 || pub.Gen > 0 {
+				s.lastSeq = pub.Seq
+				s.lastGen = pub.Gen
+			} else {
+				s.lastOffset = pub.Offset
+			}
+			s.mu.Unlock()
+		})
+	}
+}
+
+func (s *Subscription) handleJoin(info protocol.ClientInfo) {
+	var handler JoinHandler
+	if s.events != nil && s.events.onJoin != nil {
+		handler = s.events.onJoin
+	}
+	if handler != nil {
+		s.centrifuge.runHandler(func() {
+			handler.OnJoin(s, JoinEvent{ClientInfo: infoFromProto(info)})
+		})
+	}
+}
+
+func (s *Subscription) handleLeave(info protocol.ClientInfo) {
+	var handler LeaveHandler
+	if s.events != nil && s.events.onLeave != nil {
+		handler = s.events.onLeave
+	}
+	if handler != nil {
+		s.centrifuge.runHandler(func() {
+			handler.OnLeave(s, LeaveEvent{ClientInfo: infoFromProto(info)})
+		})
+	}
+}
+
+func (s *Subscription) handleUnsub(m protocol.Unsub) {
+	_ = s.Unsubscribe()
+	if m.Resubscribe {
+		_ = s.Subscribe()
+	}
+}
+
+func (s *Subscription) resubscribe(isResubscribe bool, clientID string) error {
+	s.mu.Lock()
+	if s.status == SUBSCRIBED || s.status == SUBSCRIBING {
+		s.mu.Unlock()
+		return nil
+	}
+	needResubscribe := s.needResubscribe
+	if !needResubscribe {
+		s.mu.Unlock()
+		return nil
+	}
+
+	s.status = SUBSCRIBING
+	s.mu.Unlock()
+
+	token, err := s.centrifuge.privateSign(s.channel, clientID)
+	if err != nil {
+		s.mu.Lock()
+		s.status = UNSUBSCRIBED
+		s.mu.Unlock()
+		return fmt.Errorf("error subscribing on channel %s: %v", s.channel, err)
+	}
+
+	s.mu.Lock()
+	if s.status != SUBSCRIBING {
+		s.mu.Unlock()
+		return nil
+	}
+
+	var isRecover bool
+	var sp streamPosition
+	if s.recover && isResubscribe {
+		isRecover = true
+		if s.lastSeq > 0 || s.lastGen > 0 {
+			sp.Seq = s.lastSeq
+			sp.Gen = s.lastGen
+		} else {
+			sp.Offset = s.lastOffset
+		}
+		sp.Epoch = s.lastEpoch
+	}
+
+	err = s.centrifuge.sendSubscribe(s.channel, isRecover, sp, token, func(res protocol.SubscribeResult, err error) {
+		if err != nil {
+			s.subscribeError(err)
+			return
+		}
+		s.subscribeSuccess(isRecover, res)
+	})
+	s.mu.Unlock()
+	return err
+}
+
+func (s *Subscription) runSubRefresh(ttl uint32, closeCh chan struct{}) {
+	if s.status != SUBSCRIBED {
+		return
+	}
+	if ttl == 0 {
+		return
+	}
+	go func(interval uint32) {
+		select {
+		case <-closeCh:
+			return
+		case <-time.After(time.Duration(interval) * time.Second):
+			s.centrifuge.sendSubRefresh(s.channel, func(result protocol.SubRefreshResult, err error) {
+				if err != nil {
+					return
+				}
+				if !result.Expires {
+					return
+				}
+				s.mu.Lock()
+				s.runSubRefresh(result.TTL, closeCh)
+				s.mu.Unlock()
+			})
+		}
+	}(ttl)
+}
+
+func (s *Subscription) processRecover(res protocol.SubscribeResult) {
+	s.mu.Lock()
+	s.lastEpoch = res.Epoch
+	s.mu.Unlock()
+	if len(res.Publications) > 0 {
+		pubs := res.Publications
+
+		// Reverse pubs to handle legacy order.
+		// TODO: remove after Centrifuge v1 released.
+		// Reverse in case of Offset not set or legacy order inside slice.
+		if len(pubs) > 1 && (pubs[0].Offset == 0 || pubs[0].Offset > pubs[1].Offset) {
+			for i := len(pubs)/2 - 1; i >= 0; i-- {
+				opp := len(pubs) - 1 - i
+				pubs[i], pubs[opp] = pubs[opp], pubs[i]
+			}
+		}
+
+		for i := 0; i < len(pubs); i++ {
+			s.handlePublication(*res.Publications[i])
+		}
+	} else {
+		s.mu.Lock()
+		if res.Seq > 0 || res.Gen > 0 {
+			s.lastSeq = res.Seq
+			s.lastGen = res.Gen
+		} else {
+			s.lastOffset = res.Offset
+		}
+		s.mu.Unlock()
+	}
+}
diff --git a/vendor/github.com/centrifugal/centrifuge-go/transport.go b/vendor/github.com/centrifugal/centrifuge-go/transport.go
new file mode 100644
index 0000000..f8309fc
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/transport.go
@@ -0,0 +1,20 @@
+package centrifuge
+
+import (
+	"time"
+
+	"github.com/centrifugal/protocol"
+)
+
+type transport interface {
+	// Read should read new Reply messages from connection.
+	// It should not be thread-safe as we will call it from one goroutine.
+	Read() (*protocol.Reply, *disconnect, error)
+	// Write should write Command to connection with specified write timeout.
+	// It should not be thread-safe as we will call it from one goroutine.
+	Write(cmd *protocol.Command, timeout time.Duration) error
+	// Close should close connection and do all clean ups required.
+	// It must be safe to call Close several times and concurrently with Read
+	// and Write methods.
+	Close() error
+}
diff --git a/vendor/github.com/centrifugal/centrifuge-go/transport_websocket.go b/vendor/github.com/centrifugal/centrifuge-go/transport_websocket.go
new file mode 100644
index 0000000..42a391f
--- /dev/null
+++ b/vendor/github.com/centrifugal/centrifuge-go/transport_websocket.go
@@ -0,0 +1,181 @@
+package centrifuge
+
+import (
+	"context"
+	"crypto/tls"
+	"encoding/json"
+	"fmt"
+	"io"
+	"net"
+	"net/http"
+	"sync"
+	"time"
+
+	"github.com/centrifugal/protocol"
+	"github.com/gorilla/websocket"
+)
+
+func extractDisconnectWebsocket(err error) *disconnect {
+	if err != nil {
+		if closeErr, ok := err.(*websocket.CloseError); ok {
+			var disconnect disconnect
+			err := json.Unmarshal([]byte(closeErr.Text), &disconnect)
+			if err == nil {
+				return &disconnect
+			}
+		}
+	}
+	return nil
+}
+
+type websocketTransport struct {
+	mu             sync.Mutex
+	conn           *websocket.Conn
+	encoding       protocol.Type
+	commandEncoder protocol.CommandEncoder
+	replyCh        chan *protocol.Reply
+	config         websocketConfig
+	disconnect     *disconnect
+	closed         bool
+	closeCh        chan struct{}
+}
+
+// websocketConfig configures Websocket transport.
+type websocketConfig struct {
+	// NetDialContext specifies the dial function for creating TCP connections. If
+	// NetDialContext is nil, net.DialContext is used.
+	NetDialContext func(ctx context.Context, network, addr string) (net.Conn, error)
+
+	// TLSConfig specifies the TLS configuration to use with tls.Client.
+	// If nil, the default configuration is used.
+	TLSConfig *tls.Config
+
+	// HandshakeTimeout specifies the duration for the handshake to complete.
+	HandshakeTimeout time.Duration
+
+	// EnableCompression specifies if the client should attempt to negotiate
+	// per message compression (RFC 7692). Setting this value to true does not
+	// guarantee that compression will be supported. Currently only "no context
+	// takeover" modes are supported.
+	EnableCompression bool
+
+	// CookieJar specifies the cookie jar.
+	// If CookieJar is nil, cookies are not sent in requests and ignored
+	// in responses.
+	CookieJar http.CookieJar
+
+	// Header specifies custom HTTP Header to send.
+	Header http.Header
+}
+
+func newWebsocketTransport(url string, encoding protocol.Type, config websocketConfig) (transport, error) {
+	wsHeaders := config.Header
+
+	dialer := &websocket.Dialer{}
+	dialer.Proxy = http.ProxyFromEnvironment
+	dialer.NetDialContext = config.NetDialContext
+
+	dialer.HandshakeTimeout = config.HandshakeTimeout
+	dialer.EnableCompression = config.EnableCompression
+	dialer.TLSClientConfig = config.TLSConfig
+	dialer.Jar = config.CookieJar
+
+	conn, resp, err := dialer.Dial(url, wsHeaders)
+	if err != nil {
+		return nil, fmt.Errorf("error dial: %v", err)
+	}
+	if resp.StatusCode != http.StatusSwitchingProtocols {
+		return nil, fmt.Errorf("wrong status code while connecting to server: %d", resp.StatusCode)
+	}
+
+	t := &websocketTransport{
+		conn:           conn,
+		replyCh:        make(chan *protocol.Reply, 128),
+		config:         config,
+		closeCh:        make(chan struct{}),
+		commandEncoder: newCommandEncoder(encoding),
+		encoding:       encoding,
+	}
+	go t.reader()
+	return t, nil
+}
+
+func (t *websocketTransport) Close() error {
+	t.mu.Lock()
+	defer t.mu.Unlock()
+	if t.closed {
+		return nil
+	}
+	t.closed = true
+	close(t.closeCh)
+	_ = t.conn.WriteControl(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""), time.Now().Add(time.Second))
+	return t.conn.Close()
+}
+
+func (t *websocketTransport) reader() {
+	defer func() { _ = t.Close() }()
+	defer close(t.replyCh)
+
+	for {
+		_, data, err := t.conn.ReadMessage()
+		if err != nil {
+			disconnect := extractDisconnectWebsocket(err)
+			t.disconnect = disconnect
+			return
+		}
+		//println("<----", strings.Trim(string(data), "\n"))
+	loop:
+		for {
+			decoder := newReplyDecoder(t.encoding, data)
+			for {
+				reply, err := decoder.Decode()
+				if err != nil {
+					if err == io.EOF {
+						break loop
+					}
+					t.disconnect = &disconnect{Reason: "decode error", Reconnect: false}
+					return
+				}
+				select {
+				case <-t.closeCh:
+					return
+				case t.replyCh <- reply:
+				default:
+					// Can't keep up with server message rate.
+					t.disconnect = &disconnect{Reason: "client slow", Reconnect: true}
+					return
+				}
+			}
+		}
+	}
+}
+
+func (t *websocketTransport) Write(cmd *protocol.Command, timeout time.Duration) error {
+	data, err := t.commandEncoder.Encode(cmd)
+	if err != nil {
+		return err
+	}
+	t.mu.Lock()
+	defer t.mu.Unlock()
+	if timeout > 0 {
+		_ = t.conn.SetWriteDeadline(time.Now().Add(timeout))
+	}
+	//println("---->", strings.Trim(string(data), "\n"))
+	if t.encoding == protocol.TypeJSON {
+		err = t.conn.WriteMessage(websocket.TextMessage, data)
+	} else {
+		err = t.conn.WriteMessage(websocket.BinaryMessage, data)
+	}
+	if timeout > 0 {
+		_ = t.conn.SetWriteDeadline(time.Time{})
+	}
+	return err
+}
+
+func (t *websocketTransport) Read() (*protocol.Reply, *disconnect, error) {
+	reply, ok := <-t.replyCh
+	if !ok {
+		return nil, t.disconnect, io.EOF
+	}
+	return reply, nil, nil
+}
diff --git a/vendor/github.com/centrifugal/protocol/.gitignore b/vendor/github.com/centrifugal/protocol/.gitignore
new file mode 100644
index 0000000..f1b40a4
--- /dev/null
+++ b/vendor/github.com/centrifugal/protocol/.gitignore
@@ -0,0 +1,3 @@
+.vscode/
+.idea/
+vendor/
diff --git a/vendor/github.com/centrifugal/protocol/LICENSE b/vendor/github.com/centrifugal/protocol/LICENSE
new file mode 100644
index 0000000..f9e021a
--- /dev/null
+++ b/vendor/github.com/centrifugal/protocol/LICENSE
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2020 Centrifugal
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/vendor/github.com/centrifugal/protocol/Makefile b/vendor/github.com/centrifugal/protocol/Makefile
new file mode 100644
index 0000000..5c6d0fb
--- /dev/null
+++ b/vendor/github.com/centrifugal/protocol/Makefile
@@ -0,0 +1,16 @@
+all: proto
+
+install:
+	go mod vendor
+	GO111MODULE=off go get -u github.com/gogo/protobuf/protoc-gen-gogofaster
+	GO111MODULE=off go get github.com/hairyhenderson/gomplate
+
+proto:
+	gomplate -f client.template > definitions/client.proto
+	GOGO=1 gomplate -f client.template > client.proto
+	cat client.proto
+	protoc --proto_path=vendor/:. --gogofaster_out=plugins=grpc:../protocol client.proto
+	rm client.proto
+
+test:
+	go test -race
diff --git a/vendor/github.com/centrifugal/protocol/client.pb.go b/vendor/github.com/centrifugal/protocol/client.pb.go
new file mode 100644
index 0000000..fa0c5a4
--- /dev/null
+++ b/vendor/github.com/centrifugal/protocol/client.pb.go
@@ -0,0 +1,8403 @@
+// Code generated by protoc-gen-gogo. DO NOT EDIT.
+// source: client.proto
+
+/*
+	Package protocol is a generated protocol buffer package.
+
+	It is generated from these files:
+		client.proto
+
+	It has these top-level messages:
+		Error
+		Command
+		Reply
+		Push
+		ClientInfo
+		Publication
+		Join
+		Leave
+		Unsub
+		Sub
+		Message
+		ConnectRequest
+		ConnectResult
+		RefreshRequest
+		RefreshResult
+		SubscribeRequest
+		SubscribeResult
+		SubRefreshRequest
+		SubRefreshResult
+		UnsubscribeRequest
+		UnsubscribeResult
+		PublishRequest
+		PublishResult
+		PresenceRequest
+		PresenceResult
+		PresenceStatsRequest
+		PresenceStatsResult
+		HistoryRequest
+		HistoryResult
+		PingRequest
+		PingResult
+		RPCRequest
+		RPCResult
+		SendRequest
+*/
+package protocol
+
+import proto "github.com/gogo/protobuf/proto"
+import fmt "fmt"
+import math "math"
+import _ "github.com/gogo/protobuf/gogoproto"
+
+import io "io"
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = fmt.Errorf
+var _ = math.Inf
+
+// This is a compile-time assertion to ensure that this generated file
+// is compatible with the proto package it is being compiled against.
+// A compilation error at this line likely means your copy of the
+// proto package needs to be updated.
+const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package
+
+type MethodType int32
+
+const (
+	MethodTypeConnect       MethodType = 0
+	MethodTypeSubscribe     MethodType = 1
+	MethodTypeUnsubscribe   MethodType = 2
+	MethodTypePublish       MethodType = 3
+	MethodTypePresence      MethodType = 4
+	MethodTypePresenceStats MethodType = 5
+	MethodTypeHistory       MethodType = 6
+	MethodTypePing          MethodType = 7
+	MethodTypeSend          MethodType = 8
+	MethodTypeRPC           MethodType = 9
+	MethodTypeRefresh       MethodType = 10
+	MethodTypeSubRefresh    MethodType = 11
+)
+
+var MethodType_name = map[int32]string{
+	0:  "CONNECT",
+	1:  "SUBSCRIBE",
+	2:  "UNSUBSCRIBE",
+	3:  "PUBLISH",
+	4:  "PRESENCE",
+	5:  "PRESENCE_STATS",
+	6:  "HISTORY",
+	7:  "PING",
+	8:  "SEND",
+	9:  "RPC",
+	10: "REFRESH",
+	11: "SUB_REFRESH",
+}
+var MethodType_value = map[string]int32{
+	"CONNECT":        0,
+	"SUBSCRIBE":      1,
+	"UNSUBSCRIBE":    2,
+	"PUBLISH":        3,
+	"PRESENCE":       4,
+	"PRESENCE_STATS": 5,
+	"HISTORY":        6,
+	"PING":           7,
+	"SEND":           8,
+	"RPC":            9,
+	"REFRESH":        10,
+	"SUB_REFRESH":    11,
+}
+
+func (x MethodType) String() string {
+	return proto.EnumName(MethodType_name, int32(x))
+}
+func (MethodType) EnumDescriptor() ([]byte, []int) { return fileDescriptorClient, []int{0} }
+
+type PushType int32
+
+const (
+	PushTypePublication PushType = 0
+	PushTypeJoin        PushType = 1
+	PushTypeLeave       PushType = 2
+	PushTypeUnsub       PushType = 3
+	PushTypeMessage     PushType = 4
+	PushTypeSub         PushType = 5
+)
+
+var PushType_name = map[int32]string{
+	0: "PUBLICATION",
+	1: "JOIN",
+	2: "LEAVE",
+	3: "UNSUB",
+	4: "MESSAGE",
+	5: "SUB",
+}
+var PushType_value = map[string]int32{
+	"PUBLICATION": 0,
+	"JOIN":        1,
+	"LEAVE":       2,
+	"UNSUB":       3,
+	"MESSAGE":     4,
+	"SUB":         5,
+}
+
+func (x PushType) String() string {
+	return proto.EnumName(PushType_name, int32(x))
+}
+func (PushType) EnumDescriptor() ([]byte, []int) { return fileDescriptorClient, []int{1} }
+
+type Error struct {
+	Code    uint32 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
+	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message"`
+}
+
+func (m *Error) Reset()                    { *m = Error{} }
+func (m *Error) String() string            { return proto.CompactTextString(m) }
+func (*Error) ProtoMessage()               {}
+func (*Error) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{0} }
+
+func (m *Error) GetCode() uint32 {
+	if m != nil {
+		return m.Code
+	}
+	return 0
+}
+
+func (m *Error) GetMessage() string {
+	if m != nil {
+		return m.Message
+	}
+	return ""
+}
+
+type Command struct {
+	ID     uint32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
+	Method MethodType `protobuf:"varint,2,opt,name=method,proto3,enum=protocol.MethodType" json:"method,omitempty"`
+	Params Raw        `protobuf:"bytes,3,opt,name=params,proto3,customtype=Raw" json:"params,omitempty"`
+}
+
+func (m *Command) Reset()                    { *m = Command{} }
+func (m *Command) String() string            { return proto.CompactTextString(m) }
+func (*Command) ProtoMessage()               {}
+func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{1} }
+
+func (m *Command) GetID() uint32 {
+	if m != nil {
+		return m.ID
+	}
+	return 0
+}
+
+func (m *Command) GetMethod() MethodType {
+	if m != nil {
+		return m.Method
+	}
+	return MethodTypeConnect
+}
+
+type Reply struct {
+	ID     uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
+	Error  *Error `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
+	Result Raw    `protobuf:"bytes,3,opt,name=result,proto3,customtype=Raw" json:"result,omitempty"`
+}
+
+func (m *Reply) Reset()                    { *m = Reply{} }
+func (m *Reply) String() string            { return proto.CompactTextString(m) }
+func (*Reply) ProtoMessage()               {}
+func (*Reply) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{2} }
+
+func (m *Reply) GetID() uint32 {
+	if m != nil {
+		return m.ID
+	}
+	return 0
+}
+
+func (m *Reply) GetError() *Error {
+	if m != nil {
+		return m.Error
+	}
+	return nil
+}
+
+type Push struct {
+	Type    PushType `protobuf:"varint,1,opt,name=type,proto3,enum=protocol.PushType" json:"type,omitempty"`
+	Channel string   `protobuf:"bytes,2,opt,name=channel,proto3" json:"channel,omitempty"`
+	Data    Raw      `protobuf:"bytes,3,opt,name=data,proto3,customtype=Raw" json:"data"`
+}
+
+func (m *Push) Reset()                    { *m = Push{} }
+func (m *Push) String() string            { return proto.CompactTextString(m) }
+func (*Push) ProtoMessage()               {}
+func (*Push) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{3} }
+
+func (m *Push) GetType() PushType {
+	if m != nil {
+		return m.Type
+	}
+	return PushTypePublication
+}
+
+func (m *Push) GetChannel() string {
+	if m != nil {
+		return m.Channel
+	}
+	return ""
+}
+
+type ClientInfo struct {
+	User     string `protobuf:"bytes,1,opt,name=user,proto3" json:"user"`
+	Client   string `protobuf:"bytes,2,opt,name=client,proto3" json:"client"`
+	ConnInfo Raw    `protobuf:"bytes,3,opt,name=conn_info,json=connInfo,proto3,customtype=Raw" json:"conn_info,omitempty"`
+	ChanInfo Raw    `protobuf:"bytes,4,opt,name=chan_info,json=chanInfo,proto3,customtype=Raw" json:"chan_info,omitempty"`
+}
+
+func (m *ClientInfo) Reset()                    { *m = ClientInfo{} }
+func (m *ClientInfo) String() string            { return proto.CompactTextString(m) }
+func (*ClientInfo) ProtoMessage()               {}
+func (*ClientInfo) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{4} }
+
+func (m *ClientInfo) GetUser() string {
+	if m != nil {
+		return m.User
+	}
+	return ""
+}
+
+func (m *ClientInfo) GetClient() string {
+	if m != nil {
+		return m.Client
+	}
+	return ""
+}
+
+type Publication struct {
+	Seq    uint32      `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
+	Gen    uint32      `protobuf:"varint,2,opt,name=gen,proto3" json:"gen,omitempty"`
+	UID    string      `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
+	Data   Raw         `protobuf:"bytes,4,opt,name=data,proto3,customtype=Raw" json:"data"`
+	Info   *ClientInfo `protobuf:"bytes,5,opt,name=info" json:"info,omitempty"`
+	Offset uint64      `protobuf:"varint,6,opt,name=offset,proto3" json:"offset,omitempty"`
+}
+
+func (m *Publication) Reset()                    { *m = Publication{} }
+func (m *Publication) String() string            { return proto.CompactTextString(m) }
+func (*Publication) ProtoMessage()               {}
+func (*Publication) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{5} }
+
+func (m *Publication) GetSeq() uint32 {
+	if m != nil {
+		return m.Seq
+	}
+	return 0
+}
+
+func (m *Publication) GetGen() uint32 {
+	if m != nil {
+		return m.Gen
+	}
+	return 0
+}
+
+func (m *Publication) GetUID() string {
+	if m != nil {
+		return m.UID
+	}
+	return ""
+}
+
+func (m *Publication) GetInfo() *ClientInfo {
+	if m != nil {
+		return m.Info
+	}
+	return nil
+}
+
+func (m *Publication) GetOffset() uint64 {
+	if m != nil {
+		return m.Offset
+	}
+	return 0
+}
+
+type Join struct {
+	Info ClientInfo `protobuf:"bytes,1,opt,name=info" json:"info"`
+}
+
+func (m *Join) Reset()                    { *m = Join{} }
+func (m *Join) String() string            { return proto.CompactTextString(m) }
+func (*Join) ProtoMessage()               {}
+func (*Join) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{6} }
+
+func (m *Join) GetInfo() ClientInfo {
+	if m != nil {
+		return m.Info
+	}
+	return ClientInfo{}
+}
+
+type Leave struct {
+	Info ClientInfo `protobuf:"bytes,1,opt,name=info" json:"info"`
+}
+
+func (m *Leave) Reset()                    { *m = Leave{} }
+func (m *Leave) String() string            { return proto.CompactTextString(m) }
+func (*Leave) ProtoMessage()               {}
+func (*Leave) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{7} }
+
+func (m *Leave) GetInfo() ClientInfo {
+	if m != nil {
+		return m.Info
+	}
+	return ClientInfo{}
+}
+
+type Unsub struct {
+	Resubscribe bool `protobuf:"varint,1,opt,name=resubscribe,proto3" json:"resubscribe,omitempty"`
+}
+
+func (m *Unsub) Reset()                    { *m = Unsub{} }
+func (m *Unsub) String() string            { return proto.CompactTextString(m) }
+func (*Unsub) ProtoMessage()               {}
+func (*Unsub) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{8} }
+
+func (m *Unsub) GetResubscribe() bool {
+	if m != nil {
+		return m.Resubscribe
+	}
+	return false
+}
+
+type Sub struct {
+	Recoverable bool   `protobuf:"varint,1,opt,name=recoverable,proto3" json:"recoverable,omitempty"`
+	Seq         uint32 `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
+	Gen         uint32 `protobuf:"varint,3,opt,name=gen,proto3" json:"gen,omitempty"`
+	Epoch       string `protobuf:"bytes,4,opt,name=epoch,proto3" json:"epoch,omitempty"`
+	Offset      uint64 `protobuf:"varint,5,opt,name=offset,proto3" json:"offset,omitempty"`
+}
+
+func (m *Sub) Reset()                    { *m = Sub{} }
+func (m *Sub) String() string            { return proto.CompactTextString(m) }
+func (*Sub) ProtoMessage()               {}
+func (*Sub) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{9} }
+
+func (m *Sub) GetRecoverable() bool {
+	if m != nil {
+		return m.Recoverable
+	}
+	return false
+}
+
+func (m *Sub) GetSeq() uint32 {
+	if m != nil {
+		return m.Seq
+	}
+	return 0
+}
+
+func (m *Sub) GetGen() uint32 {
+	if m != nil {
+		return m.Gen
+	}
+	return 0
+}
+
+func (m *Sub) GetEpoch() string {
+	if m != nil {
+		return m.Epoch
+	}
+	return ""
+}
+
+func (m *Sub) GetOffset() uint64 {
+	if m != nil {
+		return m.Offset
+	}
+	return 0
+}
+
+type Message struct {
+	Data Raw `protobuf:"bytes,1,opt,name=data,proto3,customtype=Raw" json:"data"`
+}
+
+func (m *Message) Reset()                    { *m = Message{} }
+func (m *Message) String() string            { return proto.CompactTextString(m) }
+func (*Message) ProtoMessage()               {}
+func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{10} }
+
+type ConnectRequest struct {
+	Token   string                       `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
+	Data    Raw                          `protobuf:"bytes,2,opt,name=data,proto3,customtype=Raw" json:"data,omitempty"`
+	Subs    map[string]*SubscribeRequest `protobuf:"bytes,3,rep,name=subs" json:"subs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
+	Name    string                       `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
+	Version string                       `protobuf:"bytes,5,opt,name=version,proto3" json:"version,omitempty"`
+}
+
+func (m *ConnectRequest) Reset()                    { *m = ConnectRequest{} }
+func (m *ConnectRequest) String() string            { return proto.CompactTextString(m) }
+func (*ConnectRequest) ProtoMessage()               {}
+func (*ConnectRequest) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{11} }
+
+func (m *ConnectRequest) GetToken() string {
+	if m != nil {
+		return m.Token
+	}
+	return ""
+}
+
+func (m *ConnectRequest) GetSubs() map[string]*SubscribeRequest {
+	if m != nil {
+		return m.Subs
+	}
+	return nil
+}
+
+func (m *ConnectRequest) GetName() string {
+	if m != nil {
+		return m.Name
+	}
+	return ""
+}
+
+func (m *ConnectRequest) GetVersion() string {
+	if m != nil {
+		return m.Version
+	}
+	return ""
+}
+
+type ConnectResult struct {
+	Client  string                      `protobuf:"bytes,1,opt,name=client,proto3" json:"client"`
+	Version string                      `protobuf:"bytes,2,opt,name=version,proto3" json:"version"`
+	Expires bool                        `protobuf:"varint,3,opt,name=expires,proto3" json:"expires,omitempty"`
+	TTL     uint32                      `protobuf:"varint,4,opt,name=ttl,proto3" json:"ttl,omitempty"`
+	Data    Raw                         `protobuf:"bytes,5,opt,name=data,proto3,customtype=Raw" json:"data,omitempty"`
+	Subs    map[string]*SubscribeResult `protobuf:"bytes,6,rep,name=subs" json:"subs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
+}
+
+func (m *ConnectResult) Reset()                    { *m = ConnectResult{} }
+func (m *ConnectResult) String() string            { return proto.CompactTextString(m) }
+func (*ConnectResult) ProtoMessage()               {}
+func (*ConnectResult) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{12} }
+
+func (m *ConnectResult) GetClient() string {
+	if m != nil {
+		return m.Client
+	}
+	return ""
+}
+
+func (m *ConnectResult) GetVersion() string {
+	if m != nil {
+		return m.Version
+	}
+	return ""
+}
+
+func (m *ConnectResult) GetExpires() bool {
+	if m != nil {
+		return m.Expires
+	}
+	return false
+}
+
+func (m *ConnectResult) GetTTL() uint32 {
+	if m != nil {
+		return m.TTL
+	}
+	return 0
+}
+
+func (m *ConnectResult) GetSubs() map[string]*SubscribeResult {
+	if m != nil {
+		return m.Subs
+	}
+	return nil
+}
+
+type RefreshRequest struct {
+	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token"`
+}
+
+func (m *RefreshRequest) Reset()                    { *m = RefreshRequest{} }
+func (m *RefreshRequest) String() string            { return proto.CompactTextString(m) }
+func (*RefreshRequest) ProtoMessage()               {}
+func (*RefreshRequest) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{13} }
+
+func (m *RefreshRequest) GetToken() string {
+	if m != nil {
+		return m.Token
+	}
+	return ""
+}
+
+type RefreshResult struct {
+	Client  string `protobuf:"bytes,1,opt,name=client,proto3" json:"client"`
+	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version"`
+	Expires bool   `protobuf:"varint,3,opt,name=expires,proto3" json:"expires,omitempty"`
+	TTL     uint32 `protobuf:"varint,4,opt,name=ttl,proto3" json:"ttl,omitempty"`
+}
+
+func (m *RefreshResult) Reset()                    { *m = RefreshResult{} }
+func (m *RefreshResult) String() string            { return proto.CompactTextString(m) }
+func (*RefreshResult) ProtoMessage()               {}
+func (*RefreshResult) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{14} }
+
+func (m *RefreshResult) GetClient() string {
+	if m != nil {
+		return m.Client
+	}
+	return ""
+}
+
+func (m *RefreshResult) GetVersion() string {
+	if m != nil {
+		return m.Version
+	}
+	return ""
+}
+
+func (m *RefreshResult) GetExpires() bool {
+	if m != nil {
+		return m.Expires
+	}
+	return false
+}
+
+func (m *RefreshResult) GetTTL() uint32 {
+	if m != nil {
+		return m.TTL
+	}
+	return 0
+}
+
+type SubscribeRequest struct {
+	Channel string `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel,omitempty"`
+	Token   string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
+	Recover bool   `protobuf:"varint,3,opt,name=recover,proto3" json:"recover,omitempty"`
+	Seq     uint32 `protobuf:"varint,4,opt,name=seq,proto3" json:"seq,omitempty"`
+	Gen     uint32 `protobuf:"varint,5,opt,name=gen,proto3" json:"gen,omitempty"`
+	Epoch   string `protobuf:"bytes,6,opt,name=epoch,proto3" json:"epoch,omitempty"`
+	Offset  uint64 `protobuf:"varint,7,opt,name=offset,proto3" json:"offset,omitempty"`
+}
+
+func (m *SubscribeRequest) Reset()                    { *m = SubscribeRequest{} }
+func (m *SubscribeRequest) String() string            { return proto.CompactTextString(m) }
+func (*SubscribeRequest) ProtoMessage()               {}
+func (*SubscribeRequest) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{15} }
+
+func (m *SubscribeRequest) GetChannel() string {
+	if m != nil {
+		return m.Channel
+	}
+	return ""
+}
+
+func (m *SubscribeRequest) GetToken() string {
+	if m != nil {
+		return m.Token
+	}
+	return ""
+}
+
+func (m *SubscribeRequest) GetRecover() bool {
+	if m != nil {
+		return m.Recover
+	}
+	return false
+}
+
+func (m *SubscribeRequest) GetSeq() uint32 {
+	if m != nil {
+		return m.Seq
+	}
+	return 0
+}
+
+func (m *SubscribeRequest) GetGen() uint32 {
+	if m != nil {
+		return m.Gen
+	}
+	return 0
+}
+
+func (m *SubscribeRequest) GetEpoch() string {
+	if m != nil {
+		return m.Epoch
+	}
+	return ""
+}
+
+func (m *SubscribeRequest) GetOffset() uint64 {
+	if m != nil {
+		return m.Offset
+	}
+	return 0
+}
+
+type SubscribeResult struct {
+	Expires      bool           `protobuf:"varint,1,opt,name=expires,proto3" json:"expires,omitempty"`
+	TTL          uint32         `protobuf:"varint,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
+	Recoverable  bool           `protobuf:"varint,3,opt,name=recoverable,proto3" json:"recoverable,omitempty"`
+	Seq          uint32         `protobuf:"varint,4,opt,name=seq,proto3" json:"seq,omitempty"`
+	Gen          uint32         `protobuf:"varint,5,opt,name=gen,proto3" json:"gen,omitempty"`
+	Epoch        string         `protobuf:"bytes,6,opt,name=epoch,proto3" json:"epoch,omitempty"`
+	Publications []*Publication `protobuf:"bytes,7,rep,name=publications" json:"publications,omitempty"`
+	Recovered    bool           `protobuf:"varint,8,opt,name=recovered,proto3" json:"recovered,omitempty"`
+	Offset       uint64         `protobuf:"varint,9,opt,name=offset,proto3" json:"offset,omitempty"`
+}
+
+func (m *SubscribeResult) Reset()                    { *m = SubscribeResult{} }
+func (m *SubscribeResult) String() string            { return proto.CompactTextString(m) }
+func (*SubscribeResult) ProtoMessage()               {}
+func (*SubscribeResult) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{16} }
+
+func (m *SubscribeResult) GetExpires() bool {
+	if m != nil {
+		return m.Expires
+	}
+	return false
+}
+
+func (m *SubscribeResult) GetTTL() uint32 {
+	if m != nil {
+		return m.TTL
+	}
+	return 0
+}
+
+func (m *SubscribeResult) GetRecoverable() bool {
+	if m != nil {
+		return m.Recoverable
+	}
+	return false
+}
+
+func (m *SubscribeResult) GetSeq() uint32 {
+	if m != nil {
+		return m.Seq
+	}
+	return 0
+}
+
+func (m *SubscribeResult) GetGen() uint32 {
+	if m != nil {
+		return m.Gen
+	}
+	return 0
+}
+
+func (m *SubscribeResult) GetEpoch() string {
+	if m != nil {
+		return m.Epoch
+	}
+	return ""
+}
+
+func (m *SubscribeResult) GetPublications() []*Publication {
+	if m != nil {
+		return m.Publications
+	}
+	return nil
+}
+
+func (m *SubscribeResult) GetRecovered() bool {
+	if m != nil {
+		return m.Recovered
+	}
+	return false
+}
+
+func (m *SubscribeResult) GetOffset() uint64 {
+	if m != nil {
+		return m.Offset
+	}
+	return 0
+}
+
+type SubRefreshRequest struct {
+	Channel string `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel"`
+	Token   string `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
+}
+
+func (m *SubRefreshRequest) Reset()                    { *m = SubRefreshRequest{} }
+func (m *SubRefreshRequest) String() string            { return proto.CompactTextString(m) }
+func (*SubRefreshRequest) ProtoMessage()               {}
+func (*SubRefreshRequest) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{17} }
+
+func (m *SubRefreshRequest) GetChannel() string {
+	if m != nil {
+		return m.Channel
+	}
+	return ""
+}
+
+func (m *SubRefreshRequest) GetToken() string {
+	if m != nil {
+		return m.Token
+	}
+	return ""
+}
+
+type SubRefreshResult struct {
+	Expires bool   `protobuf:"varint,1,opt,name=expires,proto3" json:"expires,omitempty"`
+	TTL     uint32 `protobuf:"varint,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
+}
+
+func (m *SubRefreshResult) Reset()                    { *m = SubRefreshResult{} }
+func (m *SubRefreshResult) String() string            { return proto.CompactTextString(m) }
+func (*SubRefreshResult) ProtoMessage()               {}
+func (*SubRefreshResult) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{18} }
+
+func (m *SubRefreshResult) GetExpires() bool {
+	if m != nil {
+		return m.Expires
+	}
+	return false
+}
+
+func (m *SubRefreshResult) GetTTL() uint32 {
+	if m != nil {
+		return m.TTL
+	}
+	return 0
+}
+
+type UnsubscribeRequest struct {
+	Channel string `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel"`
+}
+
+func (m *UnsubscribeRequest) Reset()                    { *m = UnsubscribeRequest{} }
+func (m *UnsubscribeRequest) String() string            { return proto.CompactTextString(m) }
+func (*UnsubscribeRequest) ProtoMessage()               {}
+func (*UnsubscribeRequest) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{19} }
+
+func (m *UnsubscribeRequest) GetChannel() string {
+	if m != nil {
+		return m.Channel
+	}
+	return ""
+}
+
+type UnsubscribeResult struct {
+}
+
+func (m *UnsubscribeResult) Reset()                    { *m = UnsubscribeResult{} }
+func (m *UnsubscribeResult) String() string            { return proto.CompactTextString(m) }
+func (*UnsubscribeResult) ProtoMessage()               {}
+func (*UnsubscribeResult) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{20} }
+
+type PublishRequest struct {
+	Channel string `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel"`
+	Data    Raw    `protobuf:"bytes,2,opt,name=data,proto3,customtype=Raw" json:"data"`
+}
+
+func (m *PublishRequest) Reset()                    { *m = PublishRequest{} }
+func (m *PublishRequest) String() string            { return proto.CompactTextString(m) }
+func (*PublishRequest) ProtoMessage()               {}
+func (*PublishRequest) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{21} }
+
+func (m *PublishRequest) GetChannel() string {
+	if m != nil {
+		return m.Channel
+	}
+	return ""
+}
+
+type PublishResult struct {
+}
+
+func (m *PublishResult) Reset()                    { *m = PublishResult{} }
+func (m *PublishResult) String() string            { return proto.CompactTextString(m) }
+func (*PublishResult) ProtoMessage()               {}
+func (*PublishResult) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{22} }
+
+type PresenceRequest struct {
+	Channel string `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel"`
+}
+
+func (m *PresenceRequest) Reset()                    { *m = PresenceRequest{} }
+func (m *PresenceRequest) String() string            { return proto.CompactTextString(m) }
+func (*PresenceRequest) ProtoMessage()               {}
+func (*PresenceRequest) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{23} }
+
+func (m *PresenceRequest) GetChannel() string {
+	if m != nil {
+		return m.Channel
+	}
+	return ""
+}
+
+type PresenceResult struct {
+	Presence map[string]*ClientInfo `protobuf:"bytes,1,rep,name=presence" json:"presence" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
+}
+
+func (m *PresenceResult) Reset()                    { *m = PresenceResult{} }
+func (m *PresenceResult) String() string            { return proto.CompactTextString(m) }
+func (*PresenceResult) ProtoMessage()               {}
+func (*PresenceResult) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{24} }
+
+func (m *PresenceResult) GetPresence() map[string]*ClientInfo {
+	if m != nil {
+		return m.Presence
+	}
+	return nil
+}
+
+type PresenceStatsRequest struct {
+	Channel string `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel"`
+}
+
+func (m *PresenceStatsRequest) Reset()                    { *m = PresenceStatsRequest{} }
+func (m *PresenceStatsRequest) String() string            { return proto.CompactTextString(m) }
+func (*PresenceStatsRequest) ProtoMessage()               {}
+func (*PresenceStatsRequest) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{25} }
+
+func (m *PresenceStatsRequest) GetChannel() string {
+	if m != nil {
+		return m.Channel
+	}
+	return ""
+}
+
+type PresenceStatsResult struct {
+	NumClients uint32 `protobuf:"varint,1,opt,name=num_clients,json=numClients,proto3" json:"num_clients"`
+	NumUsers   uint32 `protobuf:"varint,2,opt,name=num_users,json=numUsers,proto3" json:"num_users"`
+}
+
+func (m *PresenceStatsResult) Reset()                    { *m = PresenceStatsResult{} }
+func (m *PresenceStatsResult) String() string            { return proto.CompactTextString(m) }
+func (*PresenceStatsResult) ProtoMessage()               {}
+func (*PresenceStatsResult) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{26} }
+
+func (m *PresenceStatsResult) GetNumClients() uint32 {
+	if m != nil {
+		return m.NumClients
+	}
+	return 0
+}
+
+func (m *PresenceStatsResult) GetNumUsers() uint32 {
+	if m != nil {
+		return m.NumUsers
+	}
+	return 0
+}
+
+type HistoryRequest struct {
+	Channel string `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel"`
+}
+
+func (m *HistoryRequest) Reset()                    { *m = HistoryRequest{} }
+func (m *HistoryRequest) String() string            { return proto.CompactTextString(m) }
+func (*HistoryRequest) ProtoMessage()               {}
+func (*HistoryRequest) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{27} }
+
+func (m *HistoryRequest) GetChannel() string {
+	if m != nil {
+		return m.Channel
+	}
+	return ""
+}
+
+type HistoryResult struct {
+	Publications []*Publication `protobuf:"bytes,1,rep,name=publications" json:"publications"`
+}
+
+func (m *HistoryResult) Reset()                    { *m = HistoryResult{} }
+func (m *HistoryResult) String() string            { return proto.CompactTextString(m) }
+func (*HistoryResult) ProtoMessage()               {}
+func (*HistoryResult) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{28} }
+
+func (m *HistoryResult) GetPublications() []*Publication {
+	if m != nil {
+		return m.Publications
+	}
+	return nil
+}
+
+type PingRequest struct {
+}
+
+func (m *PingRequest) Reset()                    { *m = PingRequest{} }
+func (m *PingRequest) String() string            { return proto.CompactTextString(m) }
+func (*PingRequest) ProtoMessage()               {}
+func (*PingRequest) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{29} }
+
+type PingResult struct {
+}
+
+func (m *PingResult) Reset()                    { *m = PingResult{} }
+func (m *PingResult) String() string            { return proto.CompactTextString(m) }
+func (*PingResult) ProtoMessage()               {}
+func (*PingResult) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{30} }
+
+type RPCRequest struct {
+	Data   Raw    `protobuf:"bytes,1,opt,name=data,proto3,customtype=Raw" json:"data"`
+	Method string `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`
+}
+
+func (m *RPCRequest) Reset()                    { *m = RPCRequest{} }
+func (m *RPCRequest) String() string            { return proto.CompactTextString(m) }
+func (*RPCRequest) ProtoMessage()               {}
+func (*RPCRequest) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{31} }
+
+func (m *RPCRequest) GetMethod() string {
+	if m != nil {
+		return m.Method
+	}
+	return ""
+}
+
+type RPCResult struct {
+	Data Raw `protobuf:"bytes,1,opt,name=data,proto3,customtype=Raw" json:"data,omitempty"`
+}
+
+func (m *RPCResult) Reset()                    { *m = RPCResult{} }
+func (m *RPCResult) String() string            { return proto.CompactTextString(m) }
+func (*RPCResult) ProtoMessage()               {}
+func (*RPCResult) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{32} }
+
+type SendRequest struct {
+	Data Raw `protobuf:"bytes,1,opt,name=data,proto3,customtype=Raw" json:"data"`
+}
+
+func (m *SendRequest) Reset()                    { *m = SendRequest{} }
+func (m *SendRequest) String() string            { return proto.CompactTextString(m) }
+func (*SendRequest) ProtoMessage()               {}
+func (*SendRequest) Descriptor() ([]byte, []int) { return fileDescriptorClient, []int{33} }
+
+func init() {
+	proto.RegisterType((*Error)(nil), "protocol.Error")
+	proto.RegisterType((*Command)(nil), "protocol.Command")
+	proto.RegisterType((*Reply)(nil), "protocol.Reply")
+	proto.RegisterType((*Push)(nil), "protocol.Push")
+	proto.RegisterType((*ClientInfo)(nil), "protocol.ClientInfo")
+	proto.RegisterType((*Publication)(nil), "protocol.Publication")
+	proto.RegisterType((*Join)(nil), "protocol.Join")
+	proto.RegisterType((*Leave)(nil), "protocol.Leave")
+	proto.RegisterType((*Unsub)(nil), "protocol.Unsub")
+	proto.RegisterType((*Sub)(nil), "protocol.Sub")
+	proto.RegisterType((*Message)(nil), "protocol.Message")
+	proto.RegisterType((*ConnectRequest)(nil), "protocol.ConnectRequest")
+	proto.RegisterType((*ConnectResult)(nil), "protocol.ConnectResult")
+	proto.RegisterType((*RefreshRequest)(nil), "protocol.RefreshRequest")
+	proto.RegisterType((*RefreshResult)(nil), "protocol.RefreshResult")
+	proto.RegisterType((*SubscribeRequest)(nil), "protocol.SubscribeRequest")
+	proto.RegisterType((*SubscribeResult)(nil), "protocol.SubscribeResult")
+	proto.RegisterType((*SubRefreshRequest)(nil), "protocol.SubRefreshRequest")
+	proto.RegisterType((*SubRefreshResult)(nil), "protocol.SubRefreshResult")
+	proto.RegisterType((*UnsubscribeRequest)(nil), "protocol.UnsubscribeRequest")
+	proto.RegisterType((*UnsubscribeResult)(nil), "protocol.UnsubscribeResult")
+	proto.RegisterType((*PublishRequest)(nil), "protocol.PublishRequest")
+	proto.RegisterType((*PublishResult)(nil), "protocol.PublishResult")
+	proto.RegisterType((*PresenceRequest)(nil), "protocol.PresenceRequest")
+	proto.RegisterType((*PresenceResult)(nil), "protocol.PresenceResult")
+	proto.RegisterType((*PresenceStatsRequest)(nil), "protocol.PresenceStatsRequest")
+	proto.RegisterType((*PresenceStatsResult)(nil), "protocol.PresenceStatsResult")
+	proto.RegisterType((*HistoryRequest)(nil), "protocol.HistoryRequest")
+	proto.RegisterType((*HistoryResult)(nil), "protocol.HistoryResult")
+	proto.RegisterType((*PingRequest)(nil), "protocol.PingRequest")
+	proto.RegisterType((*PingResult)(nil), "protocol.PingResult")
+	proto.RegisterType((*RPCRequest)(nil), "protocol.RPCRequest")
+	proto.RegisterType((*RPCResult)(nil), "protocol.RPCResult")
+	proto.RegisterType((*SendRequest)(nil), "protocol.SendRequest")
+	proto.RegisterEnum("protocol.MethodType", MethodType_name, MethodType_value)
+	proto.RegisterEnum("protocol.PushType", PushType_name, PushType_value)
+}
+func (this *Error) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*Error)
+	if !ok {
+		that2, ok := that.(Error)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Code != that1.Code {
+		return false
+	}
+	if this.Message != that1.Message {
+		return false
+	}
+	return true
+}
+func (this *Command) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*Command)
+	if !ok {
+		that2, ok := that.(Command)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.ID != that1.ID {
+		return false
+	}
+	if this.Method != that1.Method {
+		return false
+	}
+	if !this.Params.Equal(that1.Params) {
+		return false
+	}
+	return true
+}
+func (this *Reply) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*Reply)
+	if !ok {
+		that2, ok := that.(Reply)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.ID != that1.ID {
+		return false
+	}
+	if !this.Error.Equal(that1.Error) {
+		return false
+	}
+	if !this.Result.Equal(that1.Result) {
+		return false
+	}
+	return true
+}
+func (this *Push) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*Push)
+	if !ok {
+		that2, ok := that.(Push)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Type != that1.Type {
+		return false
+	}
+	if this.Channel != that1.Channel {
+		return false
+	}
+	if !this.Data.Equal(that1.Data) {
+		return false
+	}
+	return true
+}
+func (this *ClientInfo) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*ClientInfo)
+	if !ok {
+		that2, ok := that.(ClientInfo)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.User != that1.User {
+		return false
+	}
+	if this.Client != that1.Client {
+		return false
+	}
+	if !this.ConnInfo.Equal(that1.ConnInfo) {
+		return false
+	}
+	if !this.ChanInfo.Equal(that1.ChanInfo) {
+		return false
+	}
+	return true
+}
+func (this *Publication) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*Publication)
+	if !ok {
+		that2, ok := that.(Publication)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Seq != that1.Seq {
+		return false
+	}
+	if this.Gen != that1.Gen {
+		return false
+	}
+	if this.UID != that1.UID {
+		return false
+	}
+	if !this.Data.Equal(that1.Data) {
+		return false
+	}
+	if !this.Info.Equal(that1.Info) {
+		return false
+	}
+	if this.Offset != that1.Offset {
+		return false
+	}
+	return true
+}
+func (this *Join) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*Join)
+	if !ok {
+		that2, ok := that.(Join)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if !this.Info.Equal(&that1.Info) {
+		return false
+	}
+	return true
+}
+func (this *Leave) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*Leave)
+	if !ok {
+		that2, ok := that.(Leave)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if !this.Info.Equal(&that1.Info) {
+		return false
+	}
+	return true
+}
+func (this *Unsub) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*Unsub)
+	if !ok {
+		that2, ok := that.(Unsub)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Resubscribe != that1.Resubscribe {
+		return false
+	}
+	return true
+}
+func (this *Sub) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*Sub)
+	if !ok {
+		that2, ok := that.(Sub)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Recoverable != that1.Recoverable {
+		return false
+	}
+	if this.Seq != that1.Seq {
+		return false
+	}
+	if this.Gen != that1.Gen {
+		return false
+	}
+	if this.Epoch != that1.Epoch {
+		return false
+	}
+	if this.Offset != that1.Offset {
+		return false
+	}
+	return true
+}
+func (this *Message) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*Message)
+	if !ok {
+		that2, ok := that.(Message)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if !this.Data.Equal(that1.Data) {
+		return false
+	}
+	return true
+}
+func (this *ConnectRequest) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*ConnectRequest)
+	if !ok {
+		that2, ok := that.(ConnectRequest)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Token != that1.Token {
+		return false
+	}
+	if !this.Data.Equal(that1.Data) {
+		return false
+	}
+	if len(this.Subs) != len(that1.Subs) {
+		return false
+	}
+	for i := range this.Subs {
+		if !this.Subs[i].Equal(that1.Subs[i]) {
+			return false
+		}
+	}
+	if this.Name != that1.Name {
+		return false
+	}
+	if this.Version != that1.Version {
+		return false
+	}
+	return true
+}
+func (this *ConnectResult) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*ConnectResult)
+	if !ok {
+		that2, ok := that.(ConnectResult)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Client != that1.Client {
+		return false
+	}
+	if this.Version != that1.Version {
+		return false
+	}
+	if this.Expires != that1.Expires {
+		return false
+	}
+	if this.TTL != that1.TTL {
+		return false
+	}
+	if !this.Data.Equal(that1.Data) {
+		return false
+	}
+	if len(this.Subs) != len(that1.Subs) {
+		return false
+	}
+	for i := range this.Subs {
+		if !this.Subs[i].Equal(that1.Subs[i]) {
+			return false
+		}
+	}
+	return true
+}
+func (this *RefreshRequest) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*RefreshRequest)
+	if !ok {
+		that2, ok := that.(RefreshRequest)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Token != that1.Token {
+		return false
+	}
+	return true
+}
+func (this *RefreshResult) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*RefreshResult)
+	if !ok {
+		that2, ok := that.(RefreshResult)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Client != that1.Client {
+		return false
+	}
+	if this.Version != that1.Version {
+		return false
+	}
+	if this.Expires != that1.Expires {
+		return false
+	}
+	if this.TTL != that1.TTL {
+		return false
+	}
+	return true
+}
+func (this *SubscribeRequest) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*SubscribeRequest)
+	if !ok {
+		that2, ok := that.(SubscribeRequest)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Channel != that1.Channel {
+		return false
+	}
+	if this.Token != that1.Token {
+		return false
+	}
+	if this.Recover != that1.Recover {
+		return false
+	}
+	if this.Seq != that1.Seq {
+		return false
+	}
+	if this.Gen != that1.Gen {
+		return false
+	}
+	if this.Epoch != that1.Epoch {
+		return false
+	}
+	if this.Offset != that1.Offset {
+		return false
+	}
+	return true
+}
+func (this *SubscribeResult) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*SubscribeResult)
+	if !ok {
+		that2, ok := that.(SubscribeResult)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Expires != that1.Expires {
+		return false
+	}
+	if this.TTL != that1.TTL {
+		return false
+	}
+	if this.Recoverable != that1.Recoverable {
+		return false
+	}
+	if this.Seq != that1.Seq {
+		return false
+	}
+	if this.Gen != that1.Gen {
+		return false
+	}
+	if this.Epoch != that1.Epoch {
+		return false
+	}
+	if len(this.Publications) != len(that1.Publications) {
+		return false
+	}
+	for i := range this.Publications {
+		if !this.Publications[i].Equal(that1.Publications[i]) {
+			return false
+		}
+	}
+	if this.Recovered != that1.Recovered {
+		return false
+	}
+	if this.Offset != that1.Offset {
+		return false
+	}
+	return true
+}
+func (this *SubRefreshRequest) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*SubRefreshRequest)
+	if !ok {
+		that2, ok := that.(SubRefreshRequest)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Channel != that1.Channel {
+		return false
+	}
+	if this.Token != that1.Token {
+		return false
+	}
+	return true
+}
+func (this *SubRefreshResult) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*SubRefreshResult)
+	if !ok {
+		that2, ok := that.(SubRefreshResult)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Expires != that1.Expires {
+		return false
+	}
+	if this.TTL != that1.TTL {
+		return false
+	}
+	return true
+}
+func (this *UnsubscribeRequest) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*UnsubscribeRequest)
+	if !ok {
+		that2, ok := that.(UnsubscribeRequest)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Channel != that1.Channel {
+		return false
+	}
+	return true
+}
+func (this *UnsubscribeResult) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*UnsubscribeResult)
+	if !ok {
+		that2, ok := that.(UnsubscribeResult)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	return true
+}
+func (this *PublishRequest) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*PublishRequest)
+	if !ok {
+		that2, ok := that.(PublishRequest)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Channel != that1.Channel {
+		return false
+	}
+	if !this.Data.Equal(that1.Data) {
+		return false
+	}
+	return true
+}
+func (this *PublishResult) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*PublishResult)
+	if !ok {
+		that2, ok := that.(PublishResult)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	return true
+}
+func (this *PresenceRequest) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*PresenceRequest)
+	if !ok {
+		that2, ok := that.(PresenceRequest)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Channel != that1.Channel {
+		return false
+	}
+	return true
+}
+func (this *PresenceResult) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*PresenceResult)
+	if !ok {
+		that2, ok := that.(PresenceResult)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if len(this.Presence) != len(that1.Presence) {
+		return false
+	}
+	for i := range this.Presence {
+		if !this.Presence[i].Equal(that1.Presence[i]) {
+			return false
+		}
+	}
+	return true
+}
+func (this *PresenceStatsRequest) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*PresenceStatsRequest)
+	if !ok {
+		that2, ok := that.(PresenceStatsRequest)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Channel != that1.Channel {
+		return false
+	}
+	return true
+}
+func (this *PresenceStatsResult) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*PresenceStatsResult)
+	if !ok {
+		that2, ok := that.(PresenceStatsResult)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.NumClients != that1.NumClients {
+		return false
+	}
+	if this.NumUsers != that1.NumUsers {
+		return false
+	}
+	return true
+}
+func (this *HistoryRequest) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*HistoryRequest)
+	if !ok {
+		that2, ok := that.(HistoryRequest)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if this.Channel != that1.Channel {
+		return false
+	}
+	return true
+}
+func (this *HistoryResult) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*HistoryResult)
+	if !ok {
+		that2, ok := that.(HistoryResult)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if len(this.Publications) != len(that1.Publications) {
+		return false
+	}
+	for i := range this.Publications {
+		if !this.Publications[i].Equal(that1.Publications[i]) {
+			return false
+		}
+	}
+	return true
+}
+func (this *PingRequest) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*PingRequest)
+	if !ok {
+		that2, ok := that.(PingRequest)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	return true
+}
+func (this *PingResult) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*PingResult)
+	if !ok {
+		that2, ok := that.(PingResult)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	return true
+}
+func (this *RPCRequest) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*RPCRequest)
+	if !ok {
+		that2, ok := that.(RPCRequest)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if !this.Data.Equal(that1.Data) {
+		return false
+	}
+	if this.Method != that1.Method {
+		return false
+	}
+	return true
+}
+func (this *RPCResult) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*RPCResult)
+	if !ok {
+		that2, ok := that.(RPCResult)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if !this.Data.Equal(that1.Data) {
+		return false
+	}
+	return true
+}
+func (this *SendRequest) Equal(that interface{}) bool {
+	if that == nil {
+		return this == nil
+	}
+
+	that1, ok := that.(*SendRequest)
+	if !ok {
+		that2, ok := that.(SendRequest)
+		if ok {
+			that1 = &that2
+		} else {
+			return false
+		}
+	}
+	if that1 == nil {
+		return this == nil
+	} else if this == nil {
+		return false
+	}
+	if !this.Data.Equal(that1.Data) {
+		return false
+	}
+	return true
+}
+func (m *Error) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Error) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if m.Code != 0 {
+		dAtA[i] = 0x8
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Code))
+	}
+	if len(m.Message) > 0 {
+		dAtA[i] = 0x12
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Message)))
+		i += copy(dAtA[i:], m.Message)
+	}
+	return i, nil
+}
+
+func (m *Command) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Command) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if m.ID != 0 {
+		dAtA[i] = 0x8
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.ID))
+	}
+	if m.Method != 0 {
+		dAtA[i] = 0x10
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Method))
+	}
+	dAtA[i] = 0x1a
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.Params.Size()))
+	n1, err := m.Params.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n1
+	return i, nil
+}
+
+func (m *Reply) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Reply) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if m.ID != 0 {
+		dAtA[i] = 0x8
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.ID))
+	}
+	if m.Error != nil {
+		dAtA[i] = 0x12
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Error.Size()))
+		n2, err := m.Error.MarshalTo(dAtA[i:])
+		if err != nil {
+			return 0, err
+		}
+		i += n2
+	}
+	dAtA[i] = 0x1a
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.Result.Size()))
+	n3, err := m.Result.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n3
+	return i, nil
+}
+
+func (m *Push) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Push) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if m.Type != 0 {
+		dAtA[i] = 0x8
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Type))
+	}
+	if len(m.Channel) > 0 {
+		dAtA[i] = 0x12
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Channel)))
+		i += copy(dAtA[i:], m.Channel)
+	}
+	dAtA[i] = 0x1a
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.Data.Size()))
+	n4, err := m.Data.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n4
+	return i, nil
+}
+
+func (m *ClientInfo) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *ClientInfo) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.User) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.User)))
+		i += copy(dAtA[i:], m.User)
+	}
+	if len(m.Client) > 0 {
+		dAtA[i] = 0x12
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Client)))
+		i += copy(dAtA[i:], m.Client)
+	}
+	dAtA[i] = 0x1a
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.ConnInfo.Size()))
+	n5, err := m.ConnInfo.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n5
+	dAtA[i] = 0x22
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.ChanInfo.Size()))
+	n6, err := m.ChanInfo.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n6
+	return i, nil
+}
+
+func (m *Publication) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Publication) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if m.Seq != 0 {
+		dAtA[i] = 0x8
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Seq))
+	}
+	if m.Gen != 0 {
+		dAtA[i] = 0x10
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Gen))
+	}
+	if len(m.UID) > 0 {
+		dAtA[i] = 0x1a
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.UID)))
+		i += copy(dAtA[i:], m.UID)
+	}
+	dAtA[i] = 0x22
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.Data.Size()))
+	n7, err := m.Data.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n7
+	if m.Info != nil {
+		dAtA[i] = 0x2a
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Info.Size()))
+		n8, err := m.Info.MarshalTo(dAtA[i:])
+		if err != nil {
+			return 0, err
+		}
+		i += n8
+	}
+	if m.Offset != 0 {
+		dAtA[i] = 0x30
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Offset))
+	}
+	return i, nil
+}
+
+func (m *Join) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Join) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	dAtA[i] = 0xa
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.Info.Size()))
+	n9, err := m.Info.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n9
+	return i, nil
+}
+
+func (m *Leave) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Leave) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	dAtA[i] = 0xa
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.Info.Size()))
+	n10, err := m.Info.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n10
+	return i, nil
+}
+
+func (m *Unsub) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Unsub) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if m.Resubscribe {
+		dAtA[i] = 0x8
+		i++
+		if m.Resubscribe {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i++
+	}
+	return i, nil
+}
+
+func (m *Sub) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Sub) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if m.Recoverable {
+		dAtA[i] = 0x8
+		i++
+		if m.Recoverable {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i++
+	}
+	if m.Seq != 0 {
+		dAtA[i] = 0x10
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Seq))
+	}
+	if m.Gen != 0 {
+		dAtA[i] = 0x18
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Gen))
+	}
+	if len(m.Epoch) > 0 {
+		dAtA[i] = 0x22
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Epoch)))
+		i += copy(dAtA[i:], m.Epoch)
+	}
+	if m.Offset != 0 {
+		dAtA[i] = 0x28
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Offset))
+	}
+	return i, nil
+}
+
+func (m *Message) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *Message) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	dAtA[i] = 0xa
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.Data.Size()))
+	n11, err := m.Data.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n11
+	return i, nil
+}
+
+func (m *ConnectRequest) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *ConnectRequest) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Token) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Token)))
+		i += copy(dAtA[i:], m.Token)
+	}
+	dAtA[i] = 0x12
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.Data.Size()))
+	n12, err := m.Data.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n12
+	if len(m.Subs) > 0 {
+		for k, _ := range m.Subs {
+			dAtA[i] = 0x1a
+			i++
+			v := m.Subs[k]
+			msgSize := 0
+			if v != nil {
+				msgSize = v.Size()
+				msgSize += 1 + sovClient(uint64(msgSize))
+			}
+			mapSize := 1 + len(k) + sovClient(uint64(len(k))) + msgSize
+			i = encodeVarintClient(dAtA, i, uint64(mapSize))
+			dAtA[i] = 0xa
+			i++
+			i = encodeVarintClient(dAtA, i, uint64(len(k)))
+			i += copy(dAtA[i:], k)
+			if v != nil {
+				dAtA[i] = 0x12
+				i++
+				i = encodeVarintClient(dAtA, i, uint64(v.Size()))
+				n13, err := v.MarshalTo(dAtA[i:])
+				if err != nil {
+					return 0, err
+				}
+				i += n13
+			}
+		}
+	}
+	if len(m.Name) > 0 {
+		dAtA[i] = 0x22
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Name)))
+		i += copy(dAtA[i:], m.Name)
+	}
+	if len(m.Version) > 0 {
+		dAtA[i] = 0x2a
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Version)))
+		i += copy(dAtA[i:], m.Version)
+	}
+	return i, nil
+}
+
+func (m *ConnectResult) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *ConnectResult) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Client) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Client)))
+		i += copy(dAtA[i:], m.Client)
+	}
+	if len(m.Version) > 0 {
+		dAtA[i] = 0x12
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Version)))
+		i += copy(dAtA[i:], m.Version)
+	}
+	if m.Expires {
+		dAtA[i] = 0x18
+		i++
+		if m.Expires {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i++
+	}
+	if m.TTL != 0 {
+		dAtA[i] = 0x20
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.TTL))
+	}
+	dAtA[i] = 0x2a
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.Data.Size()))
+	n14, err := m.Data.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n14
+	if len(m.Subs) > 0 {
+		for k, _ := range m.Subs {
+			dAtA[i] = 0x32
+			i++
+			v := m.Subs[k]
+			msgSize := 0
+			if v != nil {
+				msgSize = v.Size()
+				msgSize += 1 + sovClient(uint64(msgSize))
+			}
+			mapSize := 1 + len(k) + sovClient(uint64(len(k))) + msgSize
+			i = encodeVarintClient(dAtA, i, uint64(mapSize))
+			dAtA[i] = 0xa
+			i++
+			i = encodeVarintClient(dAtA, i, uint64(len(k)))
+			i += copy(dAtA[i:], k)
+			if v != nil {
+				dAtA[i] = 0x12
+				i++
+				i = encodeVarintClient(dAtA, i, uint64(v.Size()))
+				n15, err := v.MarshalTo(dAtA[i:])
+				if err != nil {
+					return 0, err
+				}
+				i += n15
+			}
+		}
+	}
+	return i, nil
+}
+
+func (m *RefreshRequest) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *RefreshRequest) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Token) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Token)))
+		i += copy(dAtA[i:], m.Token)
+	}
+	return i, nil
+}
+
+func (m *RefreshResult) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *RefreshResult) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Client) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Client)))
+		i += copy(dAtA[i:], m.Client)
+	}
+	if len(m.Version) > 0 {
+		dAtA[i] = 0x12
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Version)))
+		i += copy(dAtA[i:], m.Version)
+	}
+	if m.Expires {
+		dAtA[i] = 0x18
+		i++
+		if m.Expires {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i++
+	}
+	if m.TTL != 0 {
+		dAtA[i] = 0x20
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.TTL))
+	}
+	return i, nil
+}
+
+func (m *SubscribeRequest) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *SubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Channel) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Channel)))
+		i += copy(dAtA[i:], m.Channel)
+	}
+	if len(m.Token) > 0 {
+		dAtA[i] = 0x12
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Token)))
+		i += copy(dAtA[i:], m.Token)
+	}
+	if m.Recover {
+		dAtA[i] = 0x18
+		i++
+		if m.Recover {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i++
+	}
+	if m.Seq != 0 {
+		dAtA[i] = 0x20
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Seq))
+	}
+	if m.Gen != 0 {
+		dAtA[i] = 0x28
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Gen))
+	}
+	if len(m.Epoch) > 0 {
+		dAtA[i] = 0x32
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Epoch)))
+		i += copy(dAtA[i:], m.Epoch)
+	}
+	if m.Offset != 0 {
+		dAtA[i] = 0x38
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Offset))
+	}
+	return i, nil
+}
+
+func (m *SubscribeResult) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *SubscribeResult) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if m.Expires {
+		dAtA[i] = 0x8
+		i++
+		if m.Expires {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i++
+	}
+	if m.TTL != 0 {
+		dAtA[i] = 0x10
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.TTL))
+	}
+	if m.Recoverable {
+		dAtA[i] = 0x18
+		i++
+		if m.Recoverable {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i++
+	}
+	if m.Seq != 0 {
+		dAtA[i] = 0x20
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Seq))
+	}
+	if m.Gen != 0 {
+		dAtA[i] = 0x28
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Gen))
+	}
+	if len(m.Epoch) > 0 {
+		dAtA[i] = 0x32
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Epoch)))
+		i += copy(dAtA[i:], m.Epoch)
+	}
+	if len(m.Publications) > 0 {
+		for _, msg := range m.Publications {
+			dAtA[i] = 0x3a
+			i++
+			i = encodeVarintClient(dAtA, i, uint64(msg.Size()))
+			n, err := msg.MarshalTo(dAtA[i:])
+			if err != nil {
+				return 0, err
+			}
+			i += n
+		}
+	}
+	if m.Recovered {
+		dAtA[i] = 0x40
+		i++
+		if m.Recovered {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i++
+	}
+	if m.Offset != 0 {
+		dAtA[i] = 0x48
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.Offset))
+	}
+	return i, nil
+}
+
+func (m *SubRefreshRequest) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *SubRefreshRequest) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Channel) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Channel)))
+		i += copy(dAtA[i:], m.Channel)
+	}
+	if len(m.Token) > 0 {
+		dAtA[i] = 0x12
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Token)))
+		i += copy(dAtA[i:], m.Token)
+	}
+	return i, nil
+}
+
+func (m *SubRefreshResult) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *SubRefreshResult) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if m.Expires {
+		dAtA[i] = 0x8
+		i++
+		if m.Expires {
+			dAtA[i] = 1
+		} else {
+			dAtA[i] = 0
+		}
+		i++
+	}
+	if m.TTL != 0 {
+		dAtA[i] = 0x10
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.TTL))
+	}
+	return i, nil
+}
+
+func (m *UnsubscribeRequest) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *UnsubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Channel) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Channel)))
+		i += copy(dAtA[i:], m.Channel)
+	}
+	return i, nil
+}
+
+func (m *UnsubscribeResult) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *UnsubscribeResult) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	return i, nil
+}
+
+func (m *PublishRequest) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *PublishRequest) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Channel) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Channel)))
+		i += copy(dAtA[i:], m.Channel)
+	}
+	dAtA[i] = 0x12
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.Data.Size()))
+	n16, err := m.Data.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n16
+	return i, nil
+}
+
+func (m *PublishResult) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *PublishResult) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	return i, nil
+}
+
+func (m *PresenceRequest) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *PresenceRequest) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Channel) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Channel)))
+		i += copy(dAtA[i:], m.Channel)
+	}
+	return i, nil
+}
+
+func (m *PresenceResult) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *PresenceResult) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Presence) > 0 {
+		for k, _ := range m.Presence {
+			dAtA[i] = 0xa
+			i++
+			v := m.Presence[k]
+			msgSize := 0
+			if v != nil {
+				msgSize = v.Size()
+				msgSize += 1 + sovClient(uint64(msgSize))
+			}
+			mapSize := 1 + len(k) + sovClient(uint64(len(k))) + msgSize
+			i = encodeVarintClient(dAtA, i, uint64(mapSize))
+			dAtA[i] = 0xa
+			i++
+			i = encodeVarintClient(dAtA, i, uint64(len(k)))
+			i += copy(dAtA[i:], k)
+			if v != nil {
+				dAtA[i] = 0x12
+				i++
+				i = encodeVarintClient(dAtA, i, uint64(v.Size()))
+				n17, err := v.MarshalTo(dAtA[i:])
+				if err != nil {
+					return 0, err
+				}
+				i += n17
+			}
+		}
+	}
+	return i, nil
+}
+
+func (m *PresenceStatsRequest) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *PresenceStatsRequest) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Channel) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Channel)))
+		i += copy(dAtA[i:], m.Channel)
+	}
+	return i, nil
+}
+
+func (m *PresenceStatsResult) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *PresenceStatsResult) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if m.NumClients != 0 {
+		dAtA[i] = 0x8
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.NumClients))
+	}
+	if m.NumUsers != 0 {
+		dAtA[i] = 0x10
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(m.NumUsers))
+	}
+	return i, nil
+}
+
+func (m *HistoryRequest) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HistoryRequest) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Channel) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Channel)))
+		i += copy(dAtA[i:], m.Channel)
+	}
+	return i, nil
+}
+
+func (m *HistoryResult) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *HistoryResult) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Publications) > 0 {
+		for _, msg := range m.Publications {
+			dAtA[i] = 0xa
+			i++
+			i = encodeVarintClient(dAtA, i, uint64(msg.Size()))
+			n, err := msg.MarshalTo(dAtA[i:])
+			if err != nil {
+				return 0, err
+			}
+			i += n
+		}
+	}
+	return i, nil
+}
+
+func (m *PingRequest) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *PingRequest) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	return i, nil
+}
+
+func (m *PingResult) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *PingResult) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	return i, nil
+}
+
+func (m *RPCRequest) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *RPCRequest) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	dAtA[i] = 0xa
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.Data.Size()))
+	n18, err := m.Data.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n18
+	if len(m.Method) > 0 {
+		dAtA[i] = 0x12
+		i++
+		i = encodeVarintClient(dAtA, i, uint64(len(m.Method)))
+		i += copy(dAtA[i:], m.Method)
+	}
+	return i, nil
+}
+
+func (m *RPCResult) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *RPCResult) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	dAtA[i] = 0xa
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.Data.Size()))
+	n19, err := m.Data.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n19
+	return i, nil
+}
+
+func (m *SendRequest) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *SendRequest) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	dAtA[i] = 0xa
+	i++
+	i = encodeVarintClient(dAtA, i, uint64(m.Data.Size()))
+	n20, err := m.Data.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n20
+	return i, nil
+}
+
+func encodeVarintClient(dAtA []byte, offset int, v uint64) int {
+	for v >= 1<<7 {
+		dAtA[offset] = uint8(v&0x7f | 0x80)
+		v >>= 7
+		offset++
+	}
+	dAtA[offset] = uint8(v)
+	return offset + 1
+}
+func NewPopulatedError(r randyClient, easy bool) *Error {
+	this := &Error{}
+	this.Code = uint32(r.Uint32())
+	this.Message = string(randStringClient(r))
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedCommand(r randyClient, easy bool) *Command {
+	this := &Command{}
+	this.ID = uint32(r.Uint32())
+	this.Method = MethodType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}[r.Intn(12)])
+	v1 := NewPopulatedRaw(r)
+	this.Params = *v1
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedReply(r randyClient, easy bool) *Reply {
+	this := &Reply{}
+	this.ID = uint32(r.Uint32())
+	if r.Intn(10) != 0 {
+		this.Error = NewPopulatedError(r, easy)
+	}
+	v2 := NewPopulatedRaw(r)
+	this.Result = *v2
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedPush(r randyClient, easy bool) *Push {
+	this := &Push{}
+	this.Type = PushType([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
+	this.Channel = string(randStringClient(r))
+	v3 := NewPopulatedRaw(r)
+	this.Data = *v3
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedClientInfo(r randyClient, easy bool) *ClientInfo {
+	this := &ClientInfo{}
+	this.User = string(randStringClient(r))
+	this.Client = string(randStringClient(r))
+	v4 := NewPopulatedRaw(r)
+	this.ConnInfo = *v4
+	v5 := NewPopulatedRaw(r)
+	this.ChanInfo = *v5
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedPublication(r randyClient, easy bool) *Publication {
+	this := &Publication{}
+	this.Seq = uint32(r.Uint32())
+	this.Gen = uint32(r.Uint32())
+	this.UID = string(randStringClient(r))
+	v6 := NewPopulatedRaw(r)
+	this.Data = *v6
+	if r.Intn(10) != 0 {
+		this.Info = NewPopulatedClientInfo(r, easy)
+	}
+	this.Offset = uint64(uint64(r.Uint32()))
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedJoin(r randyClient, easy bool) *Join {
+	this := &Join{}
+	v7 := NewPopulatedClientInfo(r, easy)
+	this.Info = *v7
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedLeave(r randyClient, easy bool) *Leave {
+	this := &Leave{}
+	v8 := NewPopulatedClientInfo(r, easy)
+	this.Info = *v8
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedUnsub(r randyClient, easy bool) *Unsub {
+	this := &Unsub{}
+	this.Resubscribe = bool(bool(r.Intn(2) == 0))
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedSub(r randyClient, easy bool) *Sub {
+	this := &Sub{}
+	this.Recoverable = bool(bool(r.Intn(2) == 0))
+	this.Seq = uint32(r.Uint32())
+	this.Gen = uint32(r.Uint32())
+	this.Epoch = string(randStringClient(r))
+	this.Offset = uint64(uint64(r.Uint32()))
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedMessage(r randyClient, easy bool) *Message {
+	this := &Message{}
+	v9 := NewPopulatedRaw(r)
+	this.Data = *v9
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedConnectRequest(r randyClient, easy bool) *ConnectRequest {
+	this := &ConnectRequest{}
+	this.Token = string(randStringClient(r))
+	v10 := NewPopulatedRaw(r)
+	this.Data = *v10
+	if r.Intn(10) != 0 {
+		v11 := r.Intn(10)
+		this.Subs = make(map[string]*SubscribeRequest)
+		for i := 0; i < v11; i++ {
+			this.Subs[randStringClient(r)] = NewPopulatedSubscribeRequest(r, easy)
+		}
+	}
+	this.Name = string(randStringClient(r))
+	this.Version = string(randStringClient(r))
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedConnectResult(r randyClient, easy bool) *ConnectResult {
+	this := &ConnectResult{}
+	this.Client = string(randStringClient(r))
+	this.Version = string(randStringClient(r))
+	this.Expires = bool(bool(r.Intn(2) == 0))
+	this.TTL = uint32(r.Uint32())
+	v12 := NewPopulatedRaw(r)
+	this.Data = *v12
+	if r.Intn(10) != 0 {
+		v13 := r.Intn(10)
+		this.Subs = make(map[string]*SubscribeResult)
+		for i := 0; i < v13; i++ {
+			this.Subs[randStringClient(r)] = NewPopulatedSubscribeResult(r, easy)
+		}
+	}
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedRefreshRequest(r randyClient, easy bool) *RefreshRequest {
+	this := &RefreshRequest{}
+	this.Token = string(randStringClient(r))
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedRefreshResult(r randyClient, easy bool) *RefreshResult {
+	this := &RefreshResult{}
+	this.Client = string(randStringClient(r))
+	this.Version = string(randStringClient(r))
+	this.Expires = bool(bool(r.Intn(2) == 0))
+	this.TTL = uint32(r.Uint32())
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedSubscribeRequest(r randyClient, easy bool) *SubscribeRequest {
+	this := &SubscribeRequest{}
+	this.Channel = string(randStringClient(r))
+	this.Token = string(randStringClient(r))
+	this.Recover = bool(bool(r.Intn(2) == 0))
+	this.Seq = uint32(r.Uint32())
+	this.Gen = uint32(r.Uint32())
+	this.Epoch = string(randStringClient(r))
+	this.Offset = uint64(uint64(r.Uint32()))
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedSubscribeResult(r randyClient, easy bool) *SubscribeResult {
+	this := &SubscribeResult{}
+	this.Expires = bool(bool(r.Intn(2) == 0))
+	this.TTL = uint32(r.Uint32())
+	this.Recoverable = bool(bool(r.Intn(2) == 0))
+	this.Seq = uint32(r.Uint32())
+	this.Gen = uint32(r.Uint32())
+	this.Epoch = string(randStringClient(r))
+	if r.Intn(10) != 0 {
+		v14 := r.Intn(5)
+		this.Publications = make([]*Publication, v14)
+		for i := 0; i < v14; i++ {
+			this.Publications[i] = NewPopulatedPublication(r, easy)
+		}
+	}
+	this.Recovered = bool(bool(r.Intn(2) == 0))
+	this.Offset = uint64(uint64(r.Uint32()))
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedSubRefreshRequest(r randyClient, easy bool) *SubRefreshRequest {
+	this := &SubRefreshRequest{}
+	this.Channel = string(randStringClient(r))
+	this.Token = string(randStringClient(r))
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedSubRefreshResult(r randyClient, easy bool) *SubRefreshResult {
+	this := &SubRefreshResult{}
+	this.Expires = bool(bool(r.Intn(2) == 0))
+	this.TTL = uint32(r.Uint32())
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedUnsubscribeRequest(r randyClient, easy bool) *UnsubscribeRequest {
+	this := &UnsubscribeRequest{}
+	this.Channel = string(randStringClient(r))
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedUnsubscribeResult(r randyClient, easy bool) *UnsubscribeResult {
+	this := &UnsubscribeResult{}
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedPublishRequest(r randyClient, easy bool) *PublishRequest {
+	this := &PublishRequest{}
+	this.Channel = string(randStringClient(r))
+	v15 := NewPopulatedRaw(r)
+	this.Data = *v15
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedPublishResult(r randyClient, easy bool) *PublishResult {
+	this := &PublishResult{}
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedPresenceRequest(r randyClient, easy bool) *PresenceRequest {
+	this := &PresenceRequest{}
+	this.Channel = string(randStringClient(r))
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedPresenceResult(r randyClient, easy bool) *PresenceResult {
+	this := &PresenceResult{}
+	if r.Intn(10) != 0 {
+		v16 := r.Intn(10)
+		this.Presence = make(map[string]*ClientInfo)
+		for i := 0; i < v16; i++ {
+			this.Presence[randStringClient(r)] = NewPopulatedClientInfo(r, easy)
+		}
+	}
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedPresenceStatsRequest(r randyClient, easy bool) *PresenceStatsRequest {
+	this := &PresenceStatsRequest{}
+	this.Channel = string(randStringClient(r))
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedPresenceStatsResult(r randyClient, easy bool) *PresenceStatsResult {
+	this := &PresenceStatsResult{}
+	this.NumClients = uint32(r.Uint32())
+	this.NumUsers = uint32(r.Uint32())
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedHistoryRequest(r randyClient, easy bool) *HistoryRequest {
+	this := &HistoryRequest{}
+	this.Channel = string(randStringClient(r))
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedHistoryResult(r randyClient, easy bool) *HistoryResult {
+	this := &HistoryResult{}
+	if r.Intn(10) != 0 {
+		v17 := r.Intn(5)
+		this.Publications = make([]*Publication, v17)
+		for i := 0; i < v17; i++ {
+			this.Publications[i] = NewPopulatedPublication(r, easy)
+		}
+	}
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedPingRequest(r randyClient, easy bool) *PingRequest {
+	this := &PingRequest{}
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedPingResult(r randyClient, easy bool) *PingResult {
+	this := &PingResult{}
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedRPCRequest(r randyClient, easy bool) *RPCRequest {
+	this := &RPCRequest{}
+	v18 := NewPopulatedRaw(r)
+	this.Data = *v18
+	this.Method = string(randStringClient(r))
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedRPCResult(r randyClient, easy bool) *RPCResult {
+	this := &RPCResult{}
+	v19 := NewPopulatedRaw(r)
+	this.Data = *v19
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+func NewPopulatedSendRequest(r randyClient, easy bool) *SendRequest {
+	this := &SendRequest{}
+	v20 := NewPopulatedRaw(r)
+	this.Data = *v20
+	if !easy && r.Intn(10) != 0 {
+	}
+	return this
+}
+
+type randyClient interface {
+	Float32() float32
+	Float64() float64
+	Int63() int64
+	Int31() int32
+	Uint32() uint32
+	Intn(n int) int
+}
+
+func randUTF8RuneClient(r randyClient) rune {
+	ru := r.Intn(62)
+	if ru < 10 {
+		return rune(ru + 48)
+	} else if ru < 36 {
+		return rune(ru + 55)
+	}
+	return rune(ru + 61)
+}
+func randStringClient(r randyClient) string {
+	v21 := r.Intn(100)
+	tmps := make([]rune, v21)
+	for i := 0; i < v21; i++ {
+		tmps[i] = randUTF8RuneClient(r)
+	}
+	return string(tmps)
+}
+func randUnrecognizedClient(r randyClient, maxFieldNumber int) (dAtA []byte) {
+	l := r.Intn(5)
+	for i := 0; i < l; i++ {
+		wire := r.Intn(4)
+		if wire == 3 {
+			wire = 5
+		}
+		fieldNumber := maxFieldNumber + r.Intn(100)
+		dAtA = randFieldClient(dAtA, r, fieldNumber, wire)
+	}
+	return dAtA
+}
+func randFieldClient(dAtA []byte, r randyClient, fieldNumber int, wire int) []byte {
+	key := uint32(fieldNumber)<<3 | uint32(wire)
+	switch wire {
+	case 0:
+		dAtA = encodeVarintPopulateClient(dAtA, uint64(key))
+		v22 := r.Int63()
+		if r.Intn(2) == 0 {
+			v22 *= -1
+		}
+		dAtA = encodeVarintPopulateClient(dAtA, uint64(v22))
+	case 1:
+		dAtA = encodeVarintPopulateClient(dAtA, uint64(key))
+		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
+	case 2:
+		dAtA = encodeVarintPopulateClient(dAtA, uint64(key))
+		ll := r.Intn(100)
+		dAtA = encodeVarintPopulateClient(dAtA, uint64(ll))
+		for j := 0; j < ll; j++ {
+			dAtA = append(dAtA, byte(r.Intn(256)))
+		}
+	default:
+		dAtA = encodeVarintPopulateClient(dAtA, uint64(key))
+		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
+	}
+	return dAtA
+}
+func encodeVarintPopulateClient(dAtA []byte, v uint64) []byte {
+	for v >= 1<<7 {
+		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
+		v >>= 7
+	}
+	dAtA = append(dAtA, uint8(v))
+	return dAtA
+}
+func (m *Error) Size() (n int) {
+	var l int
+	_ = l
+	if m.Code != 0 {
+		n += 1 + sovClient(uint64(m.Code))
+	}
+	l = len(m.Message)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	return n
+}
+
+func (m *Command) Size() (n int) {
+	var l int
+	_ = l
+	if m.ID != 0 {
+		n += 1 + sovClient(uint64(m.ID))
+	}
+	if m.Method != 0 {
+		n += 1 + sovClient(uint64(m.Method))
+	}
+	l = m.Params.Size()
+	n += 1 + l + sovClient(uint64(l))
+	return n
+}
+
+func (m *Reply) Size() (n int) {
+	var l int
+	_ = l
+	if m.ID != 0 {
+		n += 1 + sovClient(uint64(m.ID))
+	}
+	if m.Error != nil {
+		l = m.Error.Size()
+		n += 1 + l + sovClient(uint64(l))
+	}
+	l = m.Result.Size()
+	n += 1 + l + sovClient(uint64(l))
+	return n
+}
+
+func (m *Push) Size() (n int) {
+	var l int
+	_ = l
+	if m.Type != 0 {
+		n += 1 + sovClient(uint64(m.Type))
+	}
+	l = len(m.Channel)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	l = m.Data.Size()
+	n += 1 + l + sovClient(uint64(l))
+	return n
+}
+
+func (m *ClientInfo) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.User)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	l = len(m.Client)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	l = m.ConnInfo.Size()
+	n += 1 + l + sovClient(uint64(l))
+	l = m.ChanInfo.Size()
+	n += 1 + l + sovClient(uint64(l))
+	return n
+}
+
+func (m *Publication) Size() (n int) {
+	var l int
+	_ = l
+	if m.Seq != 0 {
+		n += 1 + sovClient(uint64(m.Seq))
+	}
+	if m.Gen != 0 {
+		n += 1 + sovClient(uint64(m.Gen))
+	}
+	l = len(m.UID)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	l = m.Data.Size()
+	n += 1 + l + sovClient(uint64(l))
+	if m.Info != nil {
+		l = m.Info.Size()
+		n += 1 + l + sovClient(uint64(l))
+	}
+	if m.Offset != 0 {
+		n += 1 + sovClient(uint64(m.Offset))
+	}
+	return n
+}
+
+func (m *Join) Size() (n int) {
+	var l int
+	_ = l
+	l = m.Info.Size()
+	n += 1 + l + sovClient(uint64(l))
+	return n
+}
+
+func (m *Leave) Size() (n int) {
+	var l int
+	_ = l
+	l = m.Info.Size()
+	n += 1 + l + sovClient(uint64(l))
+	return n
+}
+
+func (m *Unsub) Size() (n int) {
+	var l int
+	_ = l
+	if m.Resubscribe {
+		n += 2
+	}
+	return n
+}
+
+func (m *Sub) Size() (n int) {
+	var l int
+	_ = l
+	if m.Recoverable {
+		n += 2
+	}
+	if m.Seq != 0 {
+		n += 1 + sovClient(uint64(m.Seq))
+	}
+	if m.Gen != 0 {
+		n += 1 + sovClient(uint64(m.Gen))
+	}
+	l = len(m.Epoch)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	if m.Offset != 0 {
+		n += 1 + sovClient(uint64(m.Offset))
+	}
+	return n
+}
+
+func (m *Message) Size() (n int) {
+	var l int
+	_ = l
+	l = m.Data.Size()
+	n += 1 + l + sovClient(uint64(l))
+	return n
+}
+
+func (m *ConnectRequest) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.Token)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	l = m.Data.Size()
+	n += 1 + l + sovClient(uint64(l))
+	if len(m.Subs) > 0 {
+		for k, v := range m.Subs {
+			_ = k
+			_ = v
+			l = 0
+			if v != nil {
+				l = v.Size()
+				l += 1 + sovClient(uint64(l))
+			}
+			mapEntrySize := 1 + len(k) + sovClient(uint64(len(k))) + l
+			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
+		}
+	}
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	l = len(m.Version)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	return n
+}
+
+func (m *ConnectResult) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.Client)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	l = len(m.Version)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	if m.Expires {
+		n += 2
+	}
+	if m.TTL != 0 {
+		n += 1 + sovClient(uint64(m.TTL))
+	}
+	l = m.Data.Size()
+	n += 1 + l + sovClient(uint64(l))
+	if len(m.Subs) > 0 {
+		for k, v := range m.Subs {
+			_ = k
+			_ = v
+			l = 0
+			if v != nil {
+				l = v.Size()
+				l += 1 + sovClient(uint64(l))
+			}
+			mapEntrySize := 1 + len(k) + sovClient(uint64(len(k))) + l
+			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
+		}
+	}
+	return n
+}
+
+func (m *RefreshRequest) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.Token)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	return n
+}
+
+func (m *RefreshResult) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.Client)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	l = len(m.Version)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	if m.Expires {
+		n += 2
+	}
+	if m.TTL != 0 {
+		n += 1 + sovClient(uint64(m.TTL))
+	}
+	return n
+}
+
+func (m *SubscribeRequest) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.Channel)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	l = len(m.Token)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	if m.Recover {
+		n += 2
+	}
+	if m.Seq != 0 {
+		n += 1 + sovClient(uint64(m.Seq))
+	}
+	if m.Gen != 0 {
+		n += 1 + sovClient(uint64(m.Gen))
+	}
+	l = len(m.Epoch)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	if m.Offset != 0 {
+		n += 1 + sovClient(uint64(m.Offset))
+	}
+	return n
+}
+
+func (m *SubscribeResult) Size() (n int) {
+	var l int
+	_ = l
+	if m.Expires {
+		n += 2
+	}
+	if m.TTL != 0 {
+		n += 1 + sovClient(uint64(m.TTL))
+	}
+	if m.Recoverable {
+		n += 2
+	}
+	if m.Seq != 0 {
+		n += 1 + sovClient(uint64(m.Seq))
+	}
+	if m.Gen != 0 {
+		n += 1 + sovClient(uint64(m.Gen))
+	}
+	l = len(m.Epoch)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	if len(m.Publications) > 0 {
+		for _, e := range m.Publications {
+			l = e.Size()
+			n += 1 + l + sovClient(uint64(l))
+		}
+	}
+	if m.Recovered {
+		n += 2
+	}
+	if m.Offset != 0 {
+		n += 1 + sovClient(uint64(m.Offset))
+	}
+	return n
+}
+
+func (m *SubRefreshRequest) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.Channel)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	l = len(m.Token)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	return n
+}
+
+func (m *SubRefreshResult) Size() (n int) {
+	var l int
+	_ = l
+	if m.Expires {
+		n += 2
+	}
+	if m.TTL != 0 {
+		n += 1 + sovClient(uint64(m.TTL))
+	}
+	return n
+}
+
+func (m *UnsubscribeRequest) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.Channel)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	return n
+}
+
+func (m *UnsubscribeResult) Size() (n int) {
+	var l int
+	_ = l
+	return n
+}
+
+func (m *PublishRequest) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.Channel)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	l = m.Data.Size()
+	n += 1 + l + sovClient(uint64(l))
+	return n
+}
+
+func (m *PublishResult) Size() (n int) {
+	var l int
+	_ = l
+	return n
+}
+
+func (m *PresenceRequest) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.Channel)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	return n
+}
+
+func (m *PresenceResult) Size() (n int) {
+	var l int
+	_ = l
+	if len(m.Presence) > 0 {
+		for k, v := range m.Presence {
+			_ = k
+			_ = v
+			l = 0
+			if v != nil {
+				l = v.Size()
+				l += 1 + sovClient(uint64(l))
+			}
+			mapEntrySize := 1 + len(k) + sovClient(uint64(len(k))) + l
+			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
+		}
+	}
+	return n
+}
+
+func (m *PresenceStatsRequest) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.Channel)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	return n
+}
+
+func (m *PresenceStatsResult) Size() (n int) {
+	var l int
+	_ = l
+	if m.NumClients != 0 {
+		n += 1 + sovClient(uint64(m.NumClients))
+	}
+	if m.NumUsers != 0 {
+		n += 1 + sovClient(uint64(m.NumUsers))
+	}
+	return n
+}
+
+func (m *HistoryRequest) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.Channel)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	return n
+}
+
+func (m *HistoryResult) Size() (n int) {
+	var l int
+	_ = l
+	if len(m.Publications) > 0 {
+		for _, e := range m.Publications {
+			l = e.Size()
+			n += 1 + l + sovClient(uint64(l))
+		}
+	}
+	return n
+}
+
+func (m *PingRequest) Size() (n int) {
+	var l int
+	_ = l
+	return n
+}
+
+func (m *PingResult) Size() (n int) {
+	var l int
+	_ = l
+	return n
+}
+
+func (m *RPCRequest) Size() (n int) {
+	var l int
+	_ = l
+	l = m.Data.Size()
+	n += 1 + l + sovClient(uint64(l))
+	l = len(m.Method)
+	if l > 0 {
+		n += 1 + l + sovClient(uint64(l))
+	}
+	return n
+}
+
+func (m *RPCResult) Size() (n int) {
+	var l int
+	_ = l
+	l = m.Data.Size()
+	n += 1 + l + sovClient(uint64(l))
+	return n
+}
+
+func (m *SendRequest) Size() (n int) {
+	var l int
+	_ = l
+	l = m.Data.Size()
+	n += 1 + l + sovClient(uint64(l))
+	return n
+}
+
+func sovClient(x uint64) (n int) {
+	for {
+		n++
+		x >>= 7
+		if x == 0 {
+			break
+		}
+	}
+	return n
+}
+func sozClient(x uint64) (n int) {
+	return sovClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
+}
+func (m *Error) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Error: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
+			}
+			m.Code = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Code |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Message = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Command) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Command: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
+			}
+			m.ID = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.ID |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
+			}
+			m.Method = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Method |= (MethodType(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Reply) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Reply: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Reply: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
+			}
+			m.ID = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.ID |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Error == nil {
+				m.Error = &Error{}
+			}
+			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Push) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Push: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Push: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
+			}
+			m.Type = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Type |= (PushType(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Channel = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *ClientInfo) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: ClientInfo: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ClientInfo: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.User = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Client", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Client = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ConnInfo", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.ConnInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ChanInfo", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.ChanInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Publication) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Publication: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Publication: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
+			}
+			m.Seq = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Seq |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Gen", wireType)
+			}
+			m.Gen = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Gen |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.UID = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Info == nil {
+				m.Info = &ClientInfo{}
+			}
+			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 6:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
+			}
+			m.Offset = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Offset |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Join) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Join: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Join: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Leave) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Leave: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Leave: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Unsub) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Unsub: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Unsub: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Resubscribe", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.Resubscribe = bool(v != 0)
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Sub) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Sub: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Sub: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Recoverable", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.Recoverable = bool(v != 0)
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
+			}
+			m.Seq = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Seq |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Gen", wireType)
+			}
+			m.Gen = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Gen |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Epoch = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 5:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
+			}
+			m.Offset = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Offset |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *Message) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: Message: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *ConnectRequest) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: ConnectRequest: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ConnectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Token = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Subs", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Subs == nil {
+				m.Subs = make(map[string]*SubscribeRequest)
+			}
+			var mapkey string
+			var mapvalue *SubscribeRequest
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowClient
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= (uint64(b) & 0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowClient
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= (uint64(b) & 0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthClient
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var mapmsglen int
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowClient
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						mapmsglen |= (int(b) & 0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					if mapmsglen < 0 {
+						return ErrInvalidLengthClient
+					}
+					postmsgIndex := iNdEx + mapmsglen
+					if mapmsglen < 0 {
+						return ErrInvalidLengthClient
+					}
+					if postmsgIndex > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = &SubscribeRequest{}
+					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
+						return err
+					}
+					iNdEx = postmsgIndex
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipClient(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if skippy < 0 {
+						return ErrInvalidLengthClient
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.Subs[mapkey] = mapvalue
+			iNdEx = postIndex
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Version = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *ConnectResult) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: ConnectResult: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: ConnectResult: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Client", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Client = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Version = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.Expires = bool(v != 0)
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
+			}
+			m.TTL = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.TTL |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Subs", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Subs == nil {
+				m.Subs = make(map[string]*SubscribeResult)
+			}
+			var mapkey string
+			var mapvalue *SubscribeResult
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowClient
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= (uint64(b) & 0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowClient
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= (uint64(b) & 0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthClient
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var mapmsglen int
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowClient
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						mapmsglen |= (int(b) & 0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					if mapmsglen < 0 {
+						return ErrInvalidLengthClient
+					}
+					postmsgIndex := iNdEx + mapmsglen
+					if mapmsglen < 0 {
+						return ErrInvalidLengthClient
+					}
+					if postmsgIndex > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = &SubscribeResult{}
+					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
+						return err
+					}
+					iNdEx = postmsgIndex
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipClient(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if skippy < 0 {
+						return ErrInvalidLengthClient
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.Subs[mapkey] = mapvalue
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *RefreshRequest) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: RefreshRequest: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: RefreshRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Token = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *RefreshResult) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: RefreshResult: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: RefreshResult: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Client", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Client = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Version = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.Expires = bool(v != 0)
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
+			}
+			m.TTL = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.TTL |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *SubscribeRequest) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: SubscribeRequest: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: SubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Channel = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Token = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Recover", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.Recover = bool(v != 0)
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
+			}
+			m.Seq = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Seq |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 5:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Gen", wireType)
+			}
+			m.Gen = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Gen |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Epoch = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 7:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
+			}
+			m.Offset = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Offset |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *SubscribeResult) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: SubscribeResult: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: SubscribeResult: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.Expires = bool(v != 0)
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
+			}
+			m.TTL = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.TTL |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Recoverable", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.Recoverable = bool(v != 0)
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
+			}
+			m.Seq = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Seq |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 5:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Gen", wireType)
+			}
+			m.Gen = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Gen |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 6:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Epoch = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 7:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Publications", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Publications = append(m.Publications, &Publication{})
+			if err := m.Publications[len(m.Publications)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 8:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Recovered", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.Recovered = bool(v != 0)
+		case 9:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
+			}
+			m.Offset = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Offset |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *SubRefreshRequest) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: SubRefreshRequest: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: SubRefreshRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Channel = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Token = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *SubRefreshResult) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: SubRefreshResult: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: SubRefreshResult: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
+			}
+			var v int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				v |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			m.Expires = bool(v != 0)
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
+			}
+			m.TTL = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.TTL |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *UnsubscribeRequest) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: UnsubscribeRequest: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: UnsubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Channel = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *UnsubscribeResult) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: UnsubscribeResult: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: UnsubscribeResult: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *PublishRequest) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: PublishRequest: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: PublishRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Channel = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *PublishResult) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: PublishResult: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: PublishResult: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *PresenceRequest) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: PresenceRequest: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: PresenceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Channel = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *PresenceResult) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: PresenceResult: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: PresenceResult: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Presence == nil {
+				m.Presence = make(map[string]*ClientInfo)
+			}
+			var mapkey string
+			var mapvalue *ClientInfo
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowClient
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= (uint64(b) & 0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					var stringLenmapkey uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowClient
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						stringLenmapkey |= (uint64(b) & 0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthClient
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
+				} else if fieldNum == 2 {
+					var mapmsglen int
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowClient
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						mapmsglen |= (int(b) & 0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					if mapmsglen < 0 {
+						return ErrInvalidLengthClient
+					}
+					postmsgIndex := iNdEx + mapmsglen
+					if mapmsglen < 0 {
+						return ErrInvalidLengthClient
+					}
+					if postmsgIndex > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = &ClientInfo{}
+					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
+						return err
+					}
+					iNdEx = postmsgIndex
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipClient(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if skippy < 0 {
+						return ErrInvalidLengthClient
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.Presence[mapkey] = mapvalue
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *PresenceStatsRequest) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: PresenceStatsRequest: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: PresenceStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Channel = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *PresenceStatsResult) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: PresenceStatsResult: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: PresenceStatsResult: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field NumClients", wireType)
+			}
+			m.NumClients = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.NumClients |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field NumUsers", wireType)
+			}
+			m.NumUsers = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.NumUsers |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HistoryRequest) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HistoryRequest: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HistoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Channel = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *HistoryResult) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: HistoryResult: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: HistoryResult: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Publications", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Publications = append(m.Publications, &Publication{})
+			if err := m.Publications[len(m.Publications)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *PingRequest) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: PingRequest: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: PingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *PingResult) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: PingResult: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: PingResult: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *RPCRequest) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: RPCRequest: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: RPCRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Method = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *RPCResult) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: RPCResult: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: RPCResult: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *SendRequest) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: SendRequest: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: SendRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthClient
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipClient(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthClient
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func skipClient(dAtA []byte) (n int, err error) {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return 0, ErrIntOverflowClient
+			}
+			if iNdEx >= l {
+				return 0, io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		wireType := int(wire & 0x7)
+		switch wireType {
+		case 0:
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return 0, ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return 0, io.ErrUnexpectedEOF
+				}
+				iNdEx++
+				if dAtA[iNdEx-1] < 0x80 {
+					break
+				}
+			}
+			return iNdEx, nil
+		case 1:
+			iNdEx += 8
+			return iNdEx, nil
+		case 2:
+			var length int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return 0, ErrIntOverflowClient
+				}
+				if iNdEx >= l {
+					return 0, io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				length |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			iNdEx += length
+			if length < 0 {
+				return 0, ErrInvalidLengthClient
+			}
+			return iNdEx, nil
+		case 3:
+			for {
+				var innerWire uint64
+				var start int = iNdEx
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return 0, ErrIntOverflowClient
+					}
+					if iNdEx >= l {
+						return 0, io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					innerWire |= (uint64(b) & 0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				innerWireType := int(innerWire & 0x7)
+				if innerWireType == 4 {
+					break
+				}
+				next, err := skipClient(dAtA[start:])
+				if err != nil {
+					return 0, err
+				}
+				iNdEx = start + next
+			}
+			return iNdEx, nil
+		case 4:
+			return iNdEx, nil
+		case 5:
+			iNdEx += 4
+			return iNdEx, nil
+		default:
+			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
+		}
+	}
+	panic("unreachable")
+}
+
+var (
+	ErrInvalidLengthClient = fmt.Errorf("proto: negative length found during unmarshaling")
+	ErrIntOverflowClient   = fmt.Errorf("proto: integer overflow")
+)
+
+func init() { proto.RegisterFile("client.proto", fileDescriptorClient) }
+
+var fileDescriptorClient = []byte{
+	// 1796 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0xdd, 0x6f, 0xe3, 0x58,
+	0x15, 0xaf, 0xe3, 0x7c, 0x9e, 0x34, 0xa9, 0x7b, 0x3b, 0x9d, 0xc9, 0x98, 0x52, 0x1b, 0xc3, 0xcc,
+	0x76, 0xab, 0xa5, 0xdd, 0x29, 0x62, 0x77, 0x35, 0x0b, 0xbb, 0x9a, 0x64, 0xc2, 0x4e, 0x86, 0x4e,
+	0x27, 0xd8, 0x2d, 0x12, 0x02, 0x69, 0xc8, 0xc7, 0x6d, 0x6a, 0x6d, 0x62, 0x67, 0x62, 0xbb, 0xd0,
+	0xff, 0x00, 0xf2, 0xc4, 0x23, 0x0f, 0xe4, 0x09, 0x1e, 0x78, 0xe2, 0x0d, 0xc1, 0x33, 0x4f, 0xfb,
+	0x84, 0xe6, 0x19, 0x21, 0x0b, 0x8a, 0x90, 0x50, 0xfe, 0x02, 0x1e, 0xd1, 0xfd, 0xb0, 0x7d, 0x9d,
+	0xed, 0x76, 0xd2, 0x91, 0x40, 0xe2, 0x25, 0xf1, 0x3d, 0xdf, 0xe7, 0x9e, 0xdf, 0x39, 0xf7, 0xda,
+	0xb0, 0xda, 0x1b, 0xda, 0xd8, 0xf1, 0xf7, 0xc6, 0x13, 0xd7, 0x77, 0x51, 0x91, 0xfe, 0xf5, 0xdc,
+	0xa1, 0xfa, 0xf5, 0x81, 0xed, 0x9f, 0x05, 0xdd, 0xbd, 0x9e, 0x3b, 0xda, 0x1f, 0xb8, 0x03, 0x77,
+	0x9f, 0x72, 0xba, 0xc1, 0x29, 0x5d, 0xd1, 0x05, 0x7d, 0x62, 0x8a, 0xc6, 0x21, 0xe4, 0x9a, 0x93,
+	0x89, 0x3b, 0x41, 0x5b, 0x90, 0xed, 0xb9, 0x7d, 0x5c, 0x93, 0x74, 0x69, 0xa7, 0x52, 0x2f, 0xce,
+	0x43, 0x8d, 0xae, 0x4d, 0xfa, 0x8b, 0xee, 0x41, 0x61, 0x84, 0x3d, 0xaf, 0x33, 0xc0, 0xb5, 0x8c,
+	0x2e, 0xed, 0x94, 0xea, 0xe5, 0x79, 0xa8, 0x45, 0x24, 0x33, 0x7a, 0x30, 0x7e, 0x27, 0x41, 0xa1,
+	0xe1, 0x8e, 0x46, 0x1d, 0xa7, 0x8f, 0xee, 0x43, 0xc6, 0xee, 0x73, 0x73, 0xb7, 0x2f, 0x43, 0x2d,
+	0xd3, 0x7a, 0x3c, 0x0f, 0xb5, 0x55, 0xbb, 0xff, 0x8e, 0x3b, 0xb2, 0x7d, 0x3c, 0x1a, 0xfb, 0x17,
+	0x66, 0xc6, 0xee, 0xa3, 0x3a, 0xe4, 0x47, 0xd8, 0x3f, 0x73, 0xfb, 0xd4, 0x72, 0xf5, 0xe0, 0xd6,
+	0x5e, 0x94, 0xcb, 0xde, 0x33, 0x4a, 0x3f, 0xbe, 0x18, 0xe3, 0xfa, 0xad, 0x79, 0xa8, 0x29, 0x4c,
+	0x4e, 0xd0, 0xe7, 0x9a, 0xe8, 0x7d, 0xc8, 0x8f, 0x3b, 0x93, 0xce, 0xc8, 0xab, 0xc9, 0xba, 0xb4,
+	0xb3, 0x5a, 0xd7, 0x3e, 0x0b, 0xb5, 0x95, 0xbf, 0x84, 0x9a, 0x6c, 0x76, 0x7e, 0x42, 0x14, 0x19,
+	0x53, 0x54, 0x64, 0x14, 0xe3, 0x37, 0x12, 0xe4, 0x4c, 0x3c, 0x1e, 0x5e, 0x2c, 0x1d, 0xee, 0x43,
+	0xc8, 0x61, 0xb2, 0x61, 0x34, 0xda, 0xf2, 0xc1, 0x5a, 0x12, 0x2d, 0xdd, 0xc7, 0xfa, 0xc6, 0x3c,
+	0xd4, 0xd6, 0xa8, 0x84, 0xa0, 0xc8, 0x54, 0x48, 0x98, 0x13, 0xec, 0x05, 0x43, 0xff, 0x0b, 0xc2,
+	0x64, 0x4c, 0x31, 0x4c, 0x46, 0x31, 0x7e, 0x25, 0x41, 0xb6, 0x1d, 0x78, 0x67, 0xe8, 0x21, 0x64,
+	0xfd, 0x8b, 0x31, 0xab, 0x52, 0xf5, 0x00, 0x25, 0xce, 0x09, 0x97, 0x6e, 0x14, 0x9a, 0x87, 0x5a,
+	0x95, 0xc8, 0x08, 0x66, 0xa8, 0x0e, 0xda, 0x87, 0x42, 0xef, 0xac, 0xe3, 0x38, 0x78, 0xc8, 0x6b,
+	0xb8, 0x39, 0x0f, 0xb5, 0x75, 0x4e, 0x12, 0xa4, 0x23, 0x29, 0xf4, 0x16, 0x64, 0xfb, 0x1d, 0xbf,
+	0xc3, 0x83, 0xdd, 0x48, 0x07, 0x4b, 0x59, 0x26, 0xfd, 0x35, 0x5e, 0x49, 0x00, 0x0d, 0x0a, 0xc7,
+	0x96, 0x73, 0xea, 0x12, 0x28, 0x05, 0x1e, 0x9e, 0xd0, 0x20, 0x4b, 0x0c, 0x4a, 0x64, 0x6d, 0xd2,
+	0x5f, 0x64, 0x40, 0x9e, 0x41, 0x97, 0x47, 0x01, 0xf3, 0x50, 0xe3, 0x14, 0x93, 0xff, 0xa3, 0x8f,
+	0xa1, 0xd4, 0x73, 0x1d, 0xe7, 0x85, 0xed, 0x9c, 0xba, 0xdc, 0xbd, 0x91, 0x76, 0xbf, 0x11, 0xf3,
+	0x85, 0xc8, 0x8b, 0x84, 0x48, 0x43, 0x20, 0x06, 0xce, 0x3a, 0xdc, 0x40, 0xf6, 0x6a, 0x03, 0x11,
+	0x3f, 0x65, 0xe0, 0xac, 0x43, 0x0d, 0x18, 0xbf, 0xcc, 0x40, 0xb9, 0x1d, 0x74, 0x87, 0x76, 0xaf,
+	0xe3, 0xdb, 0xae, 0x83, 0xbe, 0x0a, 0xb2, 0x87, 0x5f, 0x72, 0x7c, 0xac, 0xcf, 0x43, 0xad, 0xe2,
+	0xe1, 0x97, 0x82, 0x26, 0xe1, 0x12, 0xa1, 0x01, 0x76, 0x68, 0x5e, 0x5c, 0x68, 0x80, 0x1d, 0x51,
+	0x68, 0x80, 0x1d, 0xb4, 0x0b, 0x72, 0x60, 0xf7, 0x69, 0x56, 0xa5, 0x7a, 0xed, 0x32, 0xd4, 0xe4,
+	0x13, 0x0a, 0xb5, 0x4a, 0x90, 0xc2, 0x1a, 0x11, 0x8a, 0x2b, 0x90, 0x7d, 0x4d, 0x05, 0xd0, 0xb7,
+	0x20, 0x4b, 0x53, 0xcd, 0x51, 0x50, 0x0a, 0x2d, 0x94, 0x94, 0x85, 0x21, 0x63, 0x21, 0x61, 0xaa,
+	0x85, 0xde, 0x81, 0xbc, 0x7b, 0x7a, 0xea, 0x61, 0xbf, 0x96, 0xd7, 0xa5, 0x9d, 0x2c, 0x6b, 0x36,
+	0x46, 0x11, 0xc1, 0xc8, 0x28, 0xc6, 0x47, 0x90, 0x7d, 0xea, 0xda, 0x0e, 0x7a, 0x8f, 0xfb, 0x94,
+	0xae, 0xf1, 0xb9, 0x4a, 0x42, 0x26, 0xb1, 0x12, 0x49, 0xe6, 0xcd, 0xf8, 0x18, 0x72, 0x87, 0xb8,
+	0x73, 0x8e, 0xdf, 0xd8, 0xc0, 0x63, 0xc8, 0x9d, 0x38, 0x5e, 0xd0, 0x45, 0x1f, 0x42, 0x99, 0x34,
+	0x48, 0xd7, 0xeb, 0x4d, 0xec, 0x2e, 0x6b, 0x8a, 0x62, 0xfd, 0xee, 0x3c, 0xd4, 0x36, 0x05, 0xb2,
+	0x90, 0x81, 0x28, 0x6d, 0xfc, 0x53, 0x02, 0xd9, 0x8a, 0x8c, 0xf4, 0xdc, 0x73, 0x3c, 0xe9, 0x74,
+	0x87, 0x0b, 0x46, 0x62, 0x72, 0xda, 0x48, 0x4c, 0x8e, 0x60, 0x91, 0x59, 0x06, 0x16, 0xf2, 0xb5,
+	0xb0, 0x78, 0x1b, 0x72, 0x78, 0xec, 0xf6, 0xce, 0x68, 0xad, 0x4b, 0x7c, 0x8c, 0x10, 0x42, 0x6a,
+	0x8c, 0x10, 0x82, 0x50, 0xae, 0xdc, 0x12, 0xe5, 0x3a, 0x80, 0xc2, 0x33, 0x36, 0x9e, 0x63, 0x38,
+	0x49, 0xaf, 0x6b, 0xe8, 0x7f, 0x65, 0xa0, 0xda, 0x70, 0x1d, 0x07, 0xf7, 0x7c, 0x13, 0xbf, 0x0c,
+	0xb0, 0xe7, 0x93, 0xf8, 0x7c, 0xf7, 0x53, 0xec, 0xf0, 0xae, 0xa6, 0xf1, 0x51, 0x82, 0x18, 0x1f,
+	0x25, 0xa0, 0x07, 0xdc, 0x4d, 0x86, 0xba, 0xf9, 0x72, 0xda, 0x4d, 0x95, 0xb0, 0x44, 0x04, 0x52,
+	0xfc, 0x3e, 0x85, 0x2c, 0xa9, 0x4c, 0x4d, 0xd6, 0xe5, 0x9d, 0xf2, 0x81, 0x21, 0x40, 0x21, 0x15,
+	0xc5, 0x9e, 0x15, 0x74, 0xbd, 0xa6, 0xe3, 0x4f, 0x2e, 0x18, 0x9a, 0x89, 0x8e, 0x68, 0x8b, 0xac,
+	0xd1, 0x7d, 0xc8, 0x3a, 0x9d, 0x11, 0xe6, 0x1b, 0x49, 0xe5, 0xc8, 0x5a, 0x94, 0x23, 0x6b, 0x32,
+	0x0f, 0xcf, 0xf1, 0xc4, 0xb3, 0x5d, 0x87, 0xee, 0x23, 0x9f, 0x87, 0x9c, 0x24, 0xce, 0x43, 0x4e,
+	0x52, 0x2d, 0x28, 0xc5, 0xfe, 0x91, 0x02, 0xf2, 0xa7, 0xf8, 0x82, 0xed, 0x86, 0x49, 0x1e, 0xd1,
+	0xbb, 0x90, 0x3b, 0xef, 0x0c, 0x03, 0xcc, 0x4f, 0x06, 0x35, 0x49, 0xc2, 0x8a, 0x40, 0xc7, 0xd3,
+	0x30, 0x99, 0xe0, 0xc3, 0xcc, 0x07, 0x92, 0xf1, 0x73, 0x19, 0x2a, 0x71, 0x92, 0x64, 0xd8, 0x0b,
+	0x03, 0x52, 0xfa, 0xc2, 0x01, 0x79, 0x2f, 0x89, 0x5d, 0x38, 0x8f, 0x39, 0x29, 0x8e, 0x98, 0xa4,
+	0x88, 0x7f, 0x3a, 0xb6, 0x27, 0x98, 0x1d, 0x8c, 0x45, 0x96, 0x22, 0x27, 0x89, 0x29, 0x72, 0x12,
+	0x19, 0x4e, 0xbe, 0x3f, 0xa4, 0x5b, 0x57, 0x61, 0xc3, 0xe9, 0xf8, 0xf8, 0x90, 0x20, 0xd6, 0xf7,
+	0xc5, 0x23, 0x82, 0x08, 0xc5, 0x65, 0xce, 0x2d, 0x5f, 0xe6, 0x16, 0x2f, 0x73, 0x9e, 0x96, 0xf9,
+	0x2b, 0x57, 0x94, 0x99, 0xec, 0xc0, 0x32, 0x55, 0x56, 0xcd, 0xeb, 0x8b, 0xb1, 0x9f, 0x2e, 0xc6,
+	0xdd, 0x2b, 0x8b, 0x41, 0x9c, 0x89, 0xb5, 0x78, 0x00, 0x55, 0x13, 0x9f, 0x4e, 0xb0, 0x77, 0x16,
+	0xa1, 0x5e, 0x4b, 0xa3, 0xbe, 0x34, 0x0f, 0x35, 0x46, 0xe0, 0x58, 0x37, 0xfe, 0x20, 0x41, 0x25,
+	0xd6, 0xf9, 0x7f, 0x2a, 0x9f, 0xf1, 0xa7, 0x0c, 0x28, 0x8b, 0xc0, 0x14, 0xef, 0x08, 0xd2, 0x52,
+	0x77, 0x84, 0x78, 0x2c, 0x64, 0x5e, 0x3b, 0x16, 0xf6, 0xa1, 0xc0, 0x47, 0xa7, 0x98, 0x0d, 0x27,
+	0x89, 0xb6, 0x39, 0x29, 0x1a, 0xae, 0xd9, 0x65, 0x86, 0x6b, 0x6e, 0xb9, 0xe1, 0x9a, 0xbf, 0xc1,
+	0x70, 0x2d, 0x2c, 0x31, 0x5c, 0xff, 0x2a, 0xc3, 0xda, 0x02, 0xa0, 0xc4, 0xaa, 0x49, 0x37, 0xa9,
+	0x5a, 0x66, 0x99, 0xa6, 0x5b, 0x38, 0xad, 0xe4, 0x37, 0x39, 0xad, 0xfe, 0xb7, 0x1b, 0x7a, 0x02,
+	0xab, 0xe3, 0xe4, 0x22, 0xe5, 0xd5, 0x0a, 0xb4, 0xf7, 0x37, 0xc5, 0xab, 0x6b, 0xcc, 0xad, 0xab,
+	0xf3, 0x50, 0xbb, 0x2d, 0x8a, 0x0b, 0xf6, 0x52, 0x66, 0xd0, 0x37, 0xa1, 0xc4, 0x53, 0xc3, 0xfd,
+	0x5a, 0x91, 0x6e, 0xc3, 0x1d, 0x72, 0xad, 0x8b, 0x89, 0x82, 0x66, 0x22, 0x29, 0x94, 0xb7, 0xb4,
+	0x44, 0x79, 0x7f, 0x08, 0xeb, 0x56, 0xd0, 0x5d, 0x98, 0x09, 0xf7, 0x16, 0x7b, 0x84, 0x36, 0x2f,
+	0x27, 0x25, 0x9d, 0xa1, 0xa5, 0x3b, 0xe3, 0xf3, 0xa3, 0xc3, 0xa5, 0xfd, 0x97, 0x1e, 0x1e, 0xff,
+	0x4d, 0xec, 0x18, 0x1f, 0x02, 0xa2, 0xf7, 0xa6, 0x74, 0xcb, 0x2f, 0x97, 0x8e, 0xb1, 0x01, 0xeb,
+	0x29, 0x65, 0xfa, 0x5e, 0xf2, 0x63, 0xa8, 0xd2, 0xea, 0xdd, 0x78, 0x73, 0xde, 0x4a, 0x5d, 0x11,
+	0xae, 0xb9, 0x89, 0xac, 0x41, 0x25, 0xf6, 0x40, 0x5d, 0x7e, 0x00, 0x6b, 0xed, 0x09, 0xf6, 0xb0,
+	0xd3, 0xbb, 0x69, 0x06, 0xbf, 0x97, 0xa0, 0x9a, 0xa8, 0xd2, 0xed, 0x6e, 0x43, 0x71, 0xcc, 0x29,
+	0x35, 0x89, 0xe2, 0xf2, 0xbe, 0x80, 0xcb, 0x94, 0x6c, 0xbc, 0x64, 0x07, 0xd3, 0xea, 0x3c, 0xd4,
+	0x62, 0x5d, 0x33, 0x7e, 0x52, 0xbf, 0x07, 0x95, 0x94, 0xe0, 0x15, 0x47, 0xd3, 0x6e, 0xfa, 0x68,
+	0xba, 0xf2, 0xde, 0x2b, 0x9e, 0x4a, 0xdf, 0x86, 0x5b, 0x91, 0x49, 0xcb, 0xef, 0xf8, 0xde, 0x0d,
+	0xd3, 0xf6, 0x60, 0x63, 0x41, 0x9d, 0xa6, 0xfe, 0x2e, 0x94, 0x9d, 0x60, 0xf4, 0x82, 0x1d, 0x48,
+	0x1e, 0x7f, 0xb1, 0x59, 0x9b, 0x87, 0x9a, 0x48, 0x36, 0xc1, 0x09, 0x46, 0x2c, 0x2a, 0x02, 0xb5,
+	0x12, 0x61, 0x91, 0x97, 0x38, 0x8f, 0x03, 0xae, 0x32, 0x0f, 0xb5, 0x84, 0x68, 0x16, 0x9d, 0x60,
+	0x74, 0x42, 0x9e, 0x8c, 0xf7, 0xa1, 0xfa, 0xc4, 0xf6, 0x7c, 0x77, 0x72, 0x71, 0xc3, 0x68, 0x7f,
+	0x04, 0x95, 0x58, 0x91, 0xc6, 0xf9, 0xdd, 0x85, 0xf1, 0x21, 0x5d, 0x37, 0x3e, 0x14, 0xf2, 0xca,
+	0x2e, 0x8a, 0xa7, 0x87, 0x86, 0x51, 0x81, 0x72, 0xdb, 0x76, 0x06, 0x3c, 0x26, 0x63, 0x15, 0x80,
+	0x2d, 0x29, 0xb2, 0x7a, 0x00, 0x66, 0xbb, 0x11, 0xc5, 0xbb, 0xec, 0x5d, 0x99, 0x4c, 0x14, 0xe1,
+	0xfb, 0x45, 0xe9, 0xfa, 0x2f, 0x15, 0xc6, 0x47, 0x50, 0xa2, 0x4e, 0x68, 0x6e, 0x0f, 0x52, 0x3e,
+	0x96, 0xb9, 0x41, 0x19, 0xef, 0x41, 0xd9, 0xc2, 0x4e, 0xff, 0xa6, 0x51, 0xee, 0xbe, 0x92, 0x01,
+	0x92, 0xcf, 0x29, 0xc8, 0x80, 0x42, 0xe3, 0xf9, 0xd1, 0x51, 0xb3, 0x71, 0xac, 0xac, 0xa8, 0x9b,
+	0xd3, 0x99, 0xbe, 0x9e, 0x30, 0xf9, 0x5d, 0x0c, 0xdd, 0x87, 0x92, 0x75, 0x52, 0xb7, 0x1a, 0x66,
+	0xab, 0xde, 0x54, 0x24, 0xf5, 0xce, 0x74, 0xa6, 0x6f, 0x24, 0x52, 0xf1, 0xa9, 0x87, 0x76, 0xa1,
+	0x7c, 0x72, 0x94, 0x48, 0x66, 0xd4, 0xbb, 0xd3, 0x99, 0xbe, 0x99, 0x48, 0x0a, 0x63, 0x83, 0xf8,
+	0x6d, 0x9f, 0xd4, 0x0f, 0x5b, 0xd6, 0x13, 0x45, 0x5e, 0xf4, 0xcb, 0xfb, 0x1c, 0x7d, 0x0d, 0x8a,
+	0x6d, 0xb3, 0x69, 0x35, 0x8f, 0x1a, 0x4d, 0x25, 0xab, 0xde, 0x9e, 0xce, 0x74, 0x24, 0x08, 0x71,
+	0x28, 0xa3, 0x7d, 0xa8, 0x46, 0x52, 0x2f, 0xac, 0xe3, 0x47, 0xc7, 0x96, 0x92, 0x53, 0xbf, 0x34,
+	0x9d, 0xe9, 0x77, 0x3e, 0x2f, 0x4b, 0x61, 0x4f, 0x5c, 0x3f, 0x69, 0x59, 0xc7, 0xcf, 0xcd, 0x1f,
+	0x28, 0xf9, 0x45, 0xd7, 0x1c, 0x72, 0x68, 0x0b, 0xb2, 0xed, 0xd6, 0xd1, 0x27, 0x4a, 0x41, 0x45,
+	0xd3, 0x99, 0x5e, 0x15, 0x4c, 0xd9, 0xce, 0x80, 0x70, 0xad, 0xe6, 0xd1, 0x63, 0xa5, 0xb8, 0xc8,
+	0x25, 0x15, 0x41, 0x2a, 0xc8, 0x66, 0xbb, 0xa1, 0x94, 0xd4, 0xf5, 0xe9, 0x4c, 0xaf, 0x24, 0x4c,
+	0xb3, 0xdd, 0x20, 0xbe, 0xcd, 0xe6, 0x77, 0xcc, 0xa6, 0xf5, 0x44, 0x81, 0x45, 0xdf, 0xfc, 0x00,
+	0x40, 0x6f, 0x43, 0xd9, 0x3a, 0xa9, 0xbf, 0x88, 0xe4, 0xca, 0x6a, 0x6d, 0x3a, 0xd3, 0x6f, 0xa5,
+	0x36, 0x9c, 0x8b, 0xaa, 0xd9, 0x9f, 0xfd, 0x7a, 0x7b, 0x65, 0xf7, 0xcf, 0x12, 0x14, 0xa3, 0xcf,
+	0x3e, 0x68, 0x07, 0xca, 0x74, 0x63, 0x1b, 0x8f, 0x8e, 0x5b, 0xcf, 0x8f, 0x94, 0x15, 0x56, 0xae,
+	0x88, 0x2d, 0x7e, 0xc9, 0x50, 0x21, 0xfb, 0xf4, 0x79, 0xeb, 0x48, 0x91, 0x54, 0x65, 0x3a, 0xd3,
+	0x57, 0x23, 0x11, 0xfa, 0x4a, 0xbf, 0x05, 0xb9, 0xc3, 0xe6, 0xa3, 0xef, 0x93, 0x22, 0xd2, 0x2c,
+	0x22, 0x26, 0x7b, 0x5f, 0xdf, 0x82, 0x1c, 0x2d, 0xb4, 0x22, 0xa7, 0xb9, 0xec, 0x65, 0x5c, 0x87,
+	0xc2, 0xb3, 0xa6, 0x65, 0x3d, 0xfa, 0x84, 0x54, 0x6d, 0x63, 0x3a, 0xd3, 0xd7, 0x22, 0x7e, 0xf4,
+	0xfa, 0x59, 0x03, 0x99, 0x68, 0xe7, 0xd4, 0xb5, 0xe9, 0x4c, 0x2f, 0x47, 0x5c, 0x2b, 0xe8, 0xb2,
+	0x84, 0xea, 0x5b, 0xff, 0xfe, 0xfb, 0xb6, 0xf4, 0xdb, 0xcb, 0x6d, 0xe9, 0x8f, 0x97, 0xdb, 0xd2,
+	0x67, 0x97, 0xdb, 0xd2, 0xab, 0xcb, 0x6d, 0xe9, 0x6f, 0x97, 0xdb, 0xd2, 0x2f, 0xfe, 0xb1, 0xbd,
+	0xd2, 0xcd, 0xd3, 0x8e, 0xff, 0xc6, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x0f, 0xed, 0xbc, 0xca,
+	0xf9, 0x14, 0x00, 0x00,
+}
diff --git a/vendor/github.com/centrifugal/protocol/client.template b/vendor/github.com/centrifugal/protocol/client.template
new file mode 100644
index 0000000..a10c1a9
--- /dev/null
+++ b/vendor/github.com/centrifugal/protocol/client.template
@@ -0,0 +1,217 @@
+syntax = "proto3";
+
+package protocol;
+{{if env.Getenv "GOGO"}}
+import "github.com/gogo/protobuf/gogoproto/gogo.proto";
+
+option (gogoproto.equal_all) = true;
+option (gogoproto.populate_all) = true;
+option (gogoproto.testgen_all) = true;
+{{end}}
+message Error {
+    uint32 code = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "code"]{{end}};
+    string message = 2{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "message"]{{end}};
+}
+
+enum MethodType {
+    {{ if env.Getenv "GOGO" -}}option (gogoproto.goproto_enum_prefix) = false;
+    {{ end -}}
+    CONNECT = 0{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "MethodTypeConnect"]{{end}};
+    SUBSCRIBE = 1{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "MethodTypeSubscribe"]{{end}};
+    UNSUBSCRIBE = 2{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "MethodTypeUnsubscribe"]{{end}};
+    PUBLISH = 3{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "MethodTypePublish"]{{end}};
+    PRESENCE = 4{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "MethodTypePresence"]{{end}};
+    PRESENCE_STATS = 5{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "MethodTypePresenceStats"]{{end}};
+    HISTORY = 6{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "MethodTypeHistory"]{{end}};
+    PING = 7{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "MethodTypePing"]{{end}};
+    SEND = 8{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "MethodTypeSend"]{{end}};
+    RPC = 9{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "MethodTypeRPC"]{{end}};
+    REFRESH = 10{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "MethodTypeRefresh"]{{end}};
+    SUB_REFRESH = 11{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "MethodTypeSubRefresh"]{{end}};
+}
+
+message Command {
+    uint32 id = 1{{if env.Getenv "GOGO"}} [(gogoproto.customname) = "ID", (gogoproto.jsontag) = "id,omitempty"]{{end}};
+    MethodType method = 2{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "method,omitempty"]{{end}};
+    bytes params = 3{{if env.Getenv "GOGO"}} [(gogoproto.customtype) = "Raw", (gogoproto.jsontag) = "params,omitempty", (gogoproto.nullable) = false]{{end}};
+}
+
+message Reply {
+    uint32 id = 1{{if env.Getenv "GOGO"}} [(gogoproto.customname) = "ID", (gogoproto.jsontag) = "id,omitempty"]{{end}};
+    Error error = 2{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "error,omitempty"]{{end}};
+    bytes result = 3{{if env.Getenv "GOGO"}} [(gogoproto.customtype) = "Raw", (gogoproto.jsontag) = "result,omitempty", (gogoproto.nullable) = false]{{end}};
+}
+
+enum PushType {
+    {{ if env.Getenv "GOGO" -}}option (gogoproto.goproto_enum_prefix) = false;
+    {{ end -}}
+    PUBLICATION = 0{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "PushTypePublication"]{{end}};
+    JOIN = 1{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "PushTypeJoin"]{{end}};
+    LEAVE = 2{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "PushTypeLeave"]{{end}};
+    UNSUB = 3{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "PushTypeUnsub"]{{end}};
+    MESSAGE = 4{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "PushTypeMessage"]{{end}};
+    SUB = 5{{if env.Getenv "GOGO"}} [(gogoproto.enumvalue_customname) = "PushTypeSub"]{{end}};
+}
+
+message Push {
+    PushType type = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "type,omitempty"]{{end}};
+    string channel = 2{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "channel,omitempty"]{{end}};
+    bytes data = 3{{if env.Getenv "GOGO"}} [(gogoproto.customtype) = "Raw", (gogoproto.jsontag) = "data", (gogoproto.nullable) = false]{{end}};
+}
+
+message ClientInfo {
+    string user = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "user"]{{end}};
+    string client = 2{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "client"]{{end}};
+    bytes conn_info = 3{{if env.Getenv "GOGO"}} [(gogoproto.customtype) = "Raw", (gogoproto.jsontag) = "conn_info,omitempty", (gogoproto.nullable) = false]{{end}};
+    bytes chan_info = 4{{if env.Getenv "GOGO"}} [(gogoproto.customtype) = "Raw", (gogoproto.jsontag) = "chan_info,omitempty", (gogoproto.nullable) = false]{{end}};
+}
+
+message Publication {
+    uint32 seq = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "seq,omitempty"]{{end}};
+    uint32 gen = 2{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "gen,omitempty"]{{end}};
+    string uid = 3{{if env.Getenv "GOGO"}} [(gogoproto.customname) = "UID", (gogoproto.jsontag) = "uid,omitempty"]{{end}};
+    bytes data = 4{{if env.Getenv "GOGO"}} [(gogoproto.customtype) = "Raw", (gogoproto.jsontag) = "data", (gogoproto.nullable) = false]{{end}};
+    ClientInfo info = 5{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "info,omitempty"]{{end}};
+    uint64 offset = 6{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "offset,omitempty"]{{end}};
+}
+
+message Join {
+    ClientInfo info = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "info", (gogoproto.nullable) = false]{{end}};
+}
+
+message Leave {
+    ClientInfo info = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "info", (gogoproto.nullable) = false]{{end}};
+}
+
+message Unsub {
+    bool resubscribe =1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "resubscribe,omitempty"]{{end}};
+}
+
+message Sub {
+    bool recoverable = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "recoverable,omitempty"]{{end}};
+    uint32 seq = 2{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "seq,omitempty"]{{end}};
+    uint32 gen = 3{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "gen,omitempty"]{{end}};
+    string epoch = 4{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "epoch,omitempty"]{{end}};
+    uint64 offset = 5{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "offset,omitempty"]{{end}};
+}
+
+message Message {
+    bytes data = 1{{if env.Getenv "GOGO"}} [(gogoproto.customtype) = "Raw", (gogoproto.jsontag) = "data", (gogoproto.nullable) = false]{{end}};
+}
+
+message ConnectRequest {
+    string token = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "token,omitempty"]{{end}};
+    bytes data = 2{{if env.Getenv "GOGO"}} [(gogoproto.customtype) = "Raw", (gogoproto.jsontag) = "data,omitempty", (gogoproto.nullable) = false]{{end}};
+    map<string, SubscribeRequest> subs = 3{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "subs,omitempty"]{{end}};
+    string name = 4{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "name,omitempty"]{{end}};
+    string version = 5{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "version,omitempty"]{{end}};
+}
+
+message ConnectResult {
+    string client = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "client"]{{end}};
+    string version = 2{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "version"]{{end}};
+    bool expires = 3{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "expires,omitempty"]{{end}};
+    uint32 ttl = 4{{if env.Getenv "GOGO"}} [(gogoproto.customname) = "TTL", (gogoproto.jsontag) = "ttl,omitempty"]{{end}};
+    bytes data = 5{{if env.Getenv "GOGO"}} [(gogoproto.customtype) = "Raw", (gogoproto.jsontag) = "data,omitempty", (gogoproto.nullable) = false]{{end}};
+    map<string, SubscribeResult> subs = 6{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "subs,omitempty"]{{end}};
+}
+
+message RefreshRequest {
+    string token = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "token"]{{end}};
+}
+
+message RefreshResult {
+    string client = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "client"]{{end}};
+    string version = 2{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "version"]{{end}};
+    bool expires = 3{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "expires,omitempty"]{{end}};
+    uint32 ttl = 4{{if env.Getenv "GOGO"}} [(gogoproto.customname) = "TTL", (gogoproto.jsontag) = "ttl,omitempty"]{{end}};
+}
+
+message SubscribeRequest {
+    string channel = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "channel,omitempty"]{{end}};
+    string token = 2{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "token,omitempty"]{{end}};
+    bool recover = 3{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "recover,omitempty"]{{end}};
+    uint32 seq = 4{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "seq,omitempty"]{{end}};
+    uint32 gen = 5{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "gen,omitempty"]{{end}};
+    string epoch = 6{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "epoch,omitempty"]{{end}};
+    uint64 offset = 7{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "offset,omitempty"]{{end}};
+}
+
+message SubscribeResult {
+    bool expires = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "expires,omitempty"]{{end}};
+    uint32 ttl = 2{{if env.Getenv "GOGO"}} [(gogoproto.customname) = "TTL", (gogoproto.jsontag) = "ttl,omitempty"]{{end}};
+    bool recoverable = 3{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "recoverable,omitempty"]{{end}};
+    uint32 seq = 4{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "seq,omitempty"]{{end}};
+    uint32 gen = 5{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "gen,omitempty"]{{end}};
+    string epoch = 6{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "epoch,omitempty"]{{end}};   
+    repeated Publication publications = 7{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "publications,omitempty"]{{end}};
+    bool recovered = 8{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "recovered,omitempty"]{{end}};
+    uint64 offset = 9{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "offset,omitempty"]{{end}};
+}
+
+message SubRefreshRequest {
+    string channel = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "channel"]{{end}};
+    string token = 2{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "token"]{{end}};
+}
+
+message SubRefreshResult {
+    bool expires = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "expires,omitempty"]{{end}};
+    uint32 ttl = 2{{if env.Getenv "GOGO"}} [(gogoproto.customname) = "TTL", (gogoproto.jsontag) = "ttl,omitempty"]{{end}};
+}
+
+message UnsubscribeRequest {
+    string channel = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "channel"]{{end}};
+}
+
+message UnsubscribeResult {}
+
+message PublishRequest {
+    string channel = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "channel"]{{end}};
+    bytes data = 2{{if env.Getenv "GOGO"}} [(gogoproto.customtype) = "Raw", (gogoproto.jsontag) = "data", (gogoproto.nullable) = false]{{end}};
+}
+
+message PublishResult {}
+
+message PresenceRequest {
+    string channel = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "channel"]{{end}};
+}
+
+message PresenceResult {
+    map<string, ClientInfo> presence = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "presence"]{{end}};
+}
+
+message PresenceStatsRequest {
+    string channel = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "channel"]{{end}};
+}
+
+message PresenceStatsResult {
+    uint32 num_clients = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "num_clients"]{{end}};
+    uint32 num_users = 2{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "num_users"]{{end}};
+}
+
+message HistoryRequest {
+    string channel = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "channel"]{{end}};
+}
+
+message HistoryResult {
+    repeated Publication publications = 1{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "publications"]{{end}};
+}
+
+message PingRequest {
+}
+
+message PingResult {
+}
+
+message RPCRequest{
+    bytes data = 1{{if env.Getenv "GOGO"}} [(gogoproto.customtype) = "Raw", (gogoproto.jsontag) = "data", (gogoproto.nullable) = false]{{end}};
+    string method = 2{{if env.Getenv "GOGO"}} [(gogoproto.jsontag) = "method,omitempty"]{{end}};
+}
+
+message RPCResult {
+    bytes data = 1 {{if env.Getenv "GOGO"}} [(gogoproto.customtype) = "Raw", (gogoproto.jsontag) = "data,omitempty", (gogoproto.nullable) = false]{{end}};
+}
+
+message SendRequest{
+    bytes data = 1{{if env.Getenv "GOGO"}} [(gogoproto.customtype) = "Raw", (gogoproto.jsontag) = "data", (gogoproto.nullable) = false]{{end}};
+}
diff --git a/vendor/github.com/centrifugal/protocol/decode.go b/vendor/github.com/centrifugal/protocol/decode.go
new file mode 100644
index 0000000..8c18271
--- /dev/null
+++ b/vendor/github.com/centrifugal/protocol/decode.go
@@ -0,0 +1,654 @@
+package protocol
+
+import (
+	"bytes"
+	"encoding/binary"
+	"encoding/json"
+	"fmt"
+	"io"
+	"strconv"
+	"strings"
+
+	"github.com/gogo/protobuf/proto"
+)
+
+// UnmarshalJSON helps to unmarshal comamnd method when set as string.
+func (x *MethodType) UnmarshalJSON(data []byte) error {
+	val, err := strconv.Atoi(string(data))
+	if err != nil {
+		method := strings.Trim(strings.ToUpper(string(data)), `"`)
+		if v, ok := MethodType_value[method]; ok {
+			*x = MethodType(v)
+			return nil
+		}
+		return err
+	}
+	*x = MethodType(val)
+	return nil
+}
+
+// PushDecoder ...
+type PushDecoder interface {
+	Decode([]byte) (*Push, error)
+	DecodePublication([]byte) (*Publication, error)
+	DecodeJoin([]byte) (*Join, error)
+	DecodeLeave([]byte) (*Leave, error)
+	DecodeMessage([]byte) (*Message, error)
+	DecodeUnsub([]byte) (*Unsub, error)
+	DecodeSub([]byte) (*Sub, error)
+}
+
+// JSONPushDecoder ...
+type JSONPushDecoder struct {
+}
+
+// NewJSONPushDecoder ...
+func NewJSONPushDecoder() *JSONPushDecoder {
+	return &JSONPushDecoder{}
+}
+
+// Decode ...
+func (e *JSONPushDecoder) Decode(data []byte) (*Push, error) {
+	var m Push
+	err := json.Unmarshal(data, &m)
+	if err != nil {
+		return nil, err
+	}
+	return &m, nil
+}
+
+// DecodePublication ...
+func (e *JSONPushDecoder) DecodePublication(data []byte) (*Publication, error) {
+	var m Publication
+	err := json.Unmarshal(data, &m)
+	if err != nil {
+		return nil, err
+	}
+	return &m, nil
+}
+
+// DecodeJoin ...
+func (e *JSONPushDecoder) DecodeJoin(data []byte) (*Join, error) {
+	var m Join
+	err := json.Unmarshal(data, &m)
+	if err != nil {
+		return nil, err
+	}
+	return &m, nil
+}
+
+// DecodeLeave  ...
+func (e *JSONPushDecoder) DecodeLeave(data []byte) (*Leave, error) {
+	var m Leave
+	err := json.Unmarshal(data, &m)
+	if err != nil {
+		return nil, err
+	}
+	return &m, nil
+}
+
+// DecodeMessage ...
+func (e *JSONPushDecoder) DecodeMessage(data []byte) (*Message, error) {
+	var m Message
+	err := json.Unmarshal(data, &m)
+	if err != nil {
+		return nil, err
+	}
+	return &m, nil
+}
+
+// DecodeUnsub ...
+func (e *JSONPushDecoder) DecodeUnsub(data []byte) (*Unsub, error) {
+	var m Unsub
+	err := json.Unmarshal(data, &m)
+	if err != nil {
+		return nil, err
+	}
+	return &m, nil
+}
+
+// DecodeSub ...
+func (e *JSONPushDecoder) DecodeSub(data []byte) (*Sub, error) {
+	var m Sub
+	err := json.Unmarshal(data, &m)
+	if err != nil {
+		return nil, err
+	}
+	return &m, nil
+}
+
+// ProtobufPushDecoder ...
+type ProtobufPushDecoder struct {
+}
+
+// NewProtobufPushDecoder ...
+func NewProtobufPushDecoder() *ProtobufPushDecoder {
+	return &ProtobufPushDecoder{}
+}
+
+// Decode ...
+func (e *ProtobufPushDecoder) Decode(data []byte) (*Push, error) {
+	var m Push
+	err := m.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &m, nil
+}
+
+// DecodePublication ...
+func (e *ProtobufPushDecoder) DecodePublication(data []byte) (*Publication, error) {
+	var m Publication
+	err := m.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &m, nil
+}
+
+// DecodeJoin ...
+func (e *ProtobufPushDecoder) DecodeJoin(data []byte) (*Join, error) {
+	var m Join
+	err := m.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &m, nil
+}
+
+// DecodeLeave  ...
+func (e *ProtobufPushDecoder) DecodeLeave(data []byte) (*Leave, error) {
+	var m Leave
+	err := m.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &m, nil
+}
+
+// DecodeMessage ...
+func (e *ProtobufPushDecoder) DecodeMessage(data []byte) (*Message, error) {
+	var m Message
+	err := m.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &m, nil
+}
+
+// DecodeUnsub ...
+func (e *ProtobufPushDecoder) DecodeUnsub(data []byte) (*Unsub, error) {
+	var m Unsub
+	err := m.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &m, nil
+}
+
+// DecodeSub ...
+func (e *ProtobufPushDecoder) DecodeSub(data []byte) (*Sub, error) {
+	var m Sub
+	err := m.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &m, nil
+}
+
+// CommandDecoder ...
+type CommandDecoder interface {
+	Reset([]byte) error
+	Decode() (*Command, error)
+}
+
+// JSONCommandDecoder ...
+type JSONCommandDecoder struct {
+	decoder *json.Decoder
+}
+
+// NewJSONCommandDecoder ...
+func NewJSONCommandDecoder(data []byte) *JSONCommandDecoder {
+	return &JSONCommandDecoder{
+		decoder: json.NewDecoder(bytes.NewReader(data)),
+	}
+}
+
+// Reset ...
+func (d *JSONCommandDecoder) Reset(data []byte) error {
+	d.decoder = json.NewDecoder(bytes.NewReader(data))
+	return nil
+}
+
+// Decode ...
+func (d *JSONCommandDecoder) Decode() (*Command, error) {
+	var c Command
+	err := d.decoder.Decode(&c)
+	if err != nil {
+		return nil, err
+	}
+	return &c, nil
+}
+
+// ProtobufCommandDecoder ...
+type ProtobufCommandDecoder struct {
+	data   []byte
+	offset int
+}
+
+// NewProtobufCommandDecoder ...
+func NewProtobufCommandDecoder(data []byte) *ProtobufCommandDecoder {
+	return &ProtobufCommandDecoder{
+		data: data,
+	}
+}
+
+// Reset ...
+func (d *ProtobufCommandDecoder) Reset(data []byte) error {
+	d.data = data
+	d.offset = 0
+	return nil
+}
+
+// Decode ...
+func (d *ProtobufCommandDecoder) Decode() (*Command, error) {
+	if d.offset < len(d.data) {
+		var c Command
+		l, n := binary.Uvarint(d.data[d.offset:])
+		cmdBytes := d.data[d.offset+n : d.offset+n+int(l)]
+		err := c.Unmarshal(cmdBytes)
+		if err != nil {
+			return nil, err
+		}
+		d.offset = d.offset + n + int(l)
+		return &c, nil
+	}
+	return nil, io.EOF
+}
+
+// ParamsDecoder ...
+type ParamsDecoder interface {
+	DecodeConnect([]byte) (*ConnectRequest, error)
+	DecodeRefresh([]byte) (*RefreshRequest, error)
+	DecodeSubscribe([]byte) (*SubscribeRequest, error)
+	DecodeSubRefresh([]byte) (*SubRefreshRequest, error)
+	DecodeUnsubscribe([]byte) (*UnsubscribeRequest, error)
+	DecodePublish([]byte) (*PublishRequest, error)
+	DecodePresence([]byte) (*PresenceRequest, error)
+	DecodePresenceStats([]byte) (*PresenceStatsRequest, error)
+	DecodeHistory([]byte) (*HistoryRequest, error)
+	DecodePing([]byte) (*PingRequest, error)
+	DecodeRPC([]byte) (*RPCRequest, error)
+	DecodeSend([]byte) (*SendRequest, error)
+}
+
+// JSONParamsDecoder ...
+type JSONParamsDecoder struct{}
+
+// NewJSONParamsDecoder ...
+func NewJSONParamsDecoder() *JSONParamsDecoder {
+	return &JSONParamsDecoder{}
+}
+
+// DecodeConnect ...
+func (d *JSONParamsDecoder) DecodeConnect(data []byte) (*ConnectRequest, error) {
+	var p ConnectRequest
+	if data != nil {
+		err := json.Unmarshal(data, &p)
+		if err != nil {
+			return nil, err
+		}
+	}
+	return &p, nil
+}
+
+// DecodeRefresh ...
+func (d *JSONParamsDecoder) DecodeRefresh(data []byte) (*RefreshRequest, error) {
+	var p RefreshRequest
+	err := json.Unmarshal(data, &p)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodeSubscribe ...
+func (d *JSONParamsDecoder) DecodeSubscribe(data []byte) (*SubscribeRequest, error) {
+	var p SubscribeRequest
+	err := json.Unmarshal(data, &p)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodeSubRefresh ...
+func (d *JSONParamsDecoder) DecodeSubRefresh(data []byte) (*SubRefreshRequest, error) {
+	var p SubRefreshRequest
+	err := json.Unmarshal(data, &p)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodeUnsubscribe ...
+func (d *JSONParamsDecoder) DecodeUnsubscribe(data []byte) (*UnsubscribeRequest, error) {
+	var p UnsubscribeRequest
+	err := json.Unmarshal(data, &p)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodePublish ...
+func (d *JSONParamsDecoder) DecodePublish(data []byte) (*PublishRequest, error) {
+	var p PublishRequest
+	err := json.Unmarshal(data, &p)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodePresence ...
+func (d *JSONParamsDecoder) DecodePresence(data []byte) (*PresenceRequest, error) {
+	var p PresenceRequest
+	err := json.Unmarshal(data, &p)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodePresenceStats ...
+func (d *JSONParamsDecoder) DecodePresenceStats(data []byte) (*PresenceStatsRequest, error) {
+	var p PresenceStatsRequest
+	err := json.Unmarshal(data, &p)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodeHistory ...
+func (d *JSONParamsDecoder) DecodeHistory(data []byte) (*HistoryRequest, error) {
+	var p HistoryRequest
+	err := json.Unmarshal(data, &p)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodePing ...
+func (d *JSONParamsDecoder) DecodePing(data []byte) (*PingRequest, error) {
+	var p PingRequest
+	if data != nil {
+		err := json.Unmarshal(data, &p)
+		if err != nil {
+			return nil, err
+		}
+	}
+	return &p, nil
+}
+
+// DecodeRPC ...
+func (d *JSONParamsDecoder) DecodeRPC(data []byte) (*RPCRequest, error) {
+	var p RPCRequest
+	if data != nil {
+		err := json.Unmarshal(data, &p)
+		if err != nil {
+			return nil, err
+		}
+	}
+	return &p, nil
+}
+
+// DecodeSend ...
+func (d *JSONParamsDecoder) DecodeSend(data []byte) (*SendRequest, error) {
+	var p SendRequest
+	if data != nil {
+		err := json.Unmarshal(data, &p)
+		if err != nil {
+			return nil, err
+		}
+	}
+	return &p, nil
+}
+
+// ProtobufParamsDecoder ...
+type ProtobufParamsDecoder struct{}
+
+// NewProtobufParamsDecoder ...
+func NewProtobufParamsDecoder() *ProtobufParamsDecoder {
+	return &ProtobufParamsDecoder{}
+}
+
+// DecodeConnect ...
+func (d *ProtobufParamsDecoder) DecodeConnect(data []byte) (*ConnectRequest, error) {
+	var p ConnectRequest
+	if data != nil {
+		err := p.Unmarshal(data)
+		if err != nil {
+			return nil, err
+		}
+	}
+	return &p, nil
+}
+
+// DecodeRefresh ...
+func (d *ProtobufParamsDecoder) DecodeRefresh(data []byte) (*RefreshRequest, error) {
+	var p RefreshRequest
+	err := p.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodeSubscribe ...
+func (d *ProtobufParamsDecoder) DecodeSubscribe(data []byte) (*SubscribeRequest, error) {
+	var p SubscribeRequest
+	err := p.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodeSubRefresh ...
+func (d *ProtobufParamsDecoder) DecodeSubRefresh(data []byte) (*SubRefreshRequest, error) {
+	var p SubRefreshRequest
+	err := p.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodeUnsubscribe ...
+func (d *ProtobufParamsDecoder) DecodeUnsubscribe(data []byte) (*UnsubscribeRequest, error) {
+	var p UnsubscribeRequest
+	err := p.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodePublish ...
+func (d *ProtobufParamsDecoder) DecodePublish(data []byte) (*PublishRequest, error) {
+	var p PublishRequest
+	err := p.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodePresence ...
+func (d *ProtobufParamsDecoder) DecodePresence(data []byte) (*PresenceRequest, error) {
+	var p PresenceRequest
+	err := p.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodePresenceStats ...
+func (d *ProtobufParamsDecoder) DecodePresenceStats(data []byte) (*PresenceStatsRequest, error) {
+	var p PresenceStatsRequest
+	err := p.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodeHistory ...
+func (d *ProtobufParamsDecoder) DecodeHistory(data []byte) (*HistoryRequest, error) {
+	var p HistoryRequest
+	err := p.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodePing ...
+func (d *ProtobufParamsDecoder) DecodePing(data []byte) (*PingRequest, error) {
+	var p PingRequest
+	err := p.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodeRPC ...
+func (d *ProtobufParamsDecoder) DecodeRPC(data []byte) (*RPCRequest, error) {
+	var p RPCRequest
+	err := p.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// DecodeSend ...
+func (d *ProtobufParamsDecoder) DecodeSend(data []byte) (*SendRequest, error) {
+	var p SendRequest
+	err := p.Unmarshal(data)
+	if err != nil {
+		return nil, err
+	}
+	return &p, nil
+}
+
+// ReplyDecoder ...
+type ReplyDecoder interface {
+	Reset([]byte) error
+	Decode() (*Reply, error)
+}
+
+// JSONReplyDecoder ...
+type JSONReplyDecoder struct {
+	decoder *json.Decoder
+}
+
+// NewJSONReplyDecoder ...
+func NewJSONReplyDecoder(data []byte) *JSONReplyDecoder {
+	return &JSONReplyDecoder{
+		decoder: json.NewDecoder(bytes.NewReader(data)),
+	}
+}
+
+// Reset ...
+func (d *JSONReplyDecoder) Reset(data []byte) error {
+	d.decoder = json.NewDecoder(bytes.NewReader(data))
+	return nil
+}
+
+// Decode ...
+func (d *JSONReplyDecoder) Decode() (*Reply, error) {
+	var c Reply
+	err := d.decoder.Decode(&c)
+	if err != nil {
+		return nil, err
+	}
+	return &c, nil
+}
+
+// ProtobufReplyDecoder ...
+type ProtobufReplyDecoder struct {
+	data   []byte
+	offset int
+}
+
+// NewProtobufReplyDecoder ...
+func NewProtobufReplyDecoder(data []byte) *ProtobufReplyDecoder {
+	return &ProtobufReplyDecoder{
+		data: data,
+	}
+}
+
+// Reset ...
+func (d *ProtobufReplyDecoder) Reset(data []byte) error {
+	d.data = data
+	d.offset = 0
+	return nil
+}
+
+// Decode ...
+func (d *ProtobufReplyDecoder) Decode() (*Reply, error) {
+	if d.offset < len(d.data) {
+		var c Reply
+		l, n := binary.Uvarint(d.data[d.offset:])
+		replyBytes := d.data[d.offset+n : d.offset+n+int(l)]
+		err := c.Unmarshal(replyBytes)
+		if err != nil {
+			return nil, err
+		}
+		d.offset = d.offset + n + int(l)
+		return &c, nil
+	}
+	return nil, io.EOF
+}
+
+// ResultDecoder ...
+type ResultDecoder interface {
+	Decode([]byte, interface{}) error
+}
+
+// JSONResultDecoder ...
+type JSONResultDecoder struct{}
+
+// NewJSONResultDecoder ...
+func NewJSONResultDecoder() *JSONResultDecoder {
+	return &JSONResultDecoder{}
+}
+
+// Decode ...
+func (e *JSONResultDecoder) Decode(data []byte, dest interface{}) error {
+	return json.Unmarshal(data, dest)
+}
+
+// ProtobufResultDecoder ...
+type ProtobufResultDecoder struct{}
+
+// NewProtobufResultDecoder ...
+func NewProtobufResultDecoder() *ProtobufResultDecoder {
+	return &ProtobufResultDecoder{}
+}
+
+// Decode ...
+func (e *ProtobufResultDecoder) Decode(data []byte, dest interface{}) error {
+	m, ok := dest.(proto.Unmarshaler)
+	if !ok {
+		return fmt.Errorf("can not unmarshal type from Protobuf")
+	}
+	return m.Unmarshal(data)
+}
diff --git a/vendor/github.com/centrifugal/protocol/encode.go b/vendor/github.com/centrifugal/protocol/encode.go
new file mode 100644
index 0000000..5cae413
--- /dev/null
+++ b/vendor/github.com/centrifugal/protocol/encode.go
@@ -0,0 +1,404 @@
+package protocol
+
+import (
+	"bytes"
+	"encoding/binary"
+	"encoding/json"
+	"fmt"
+
+	"github.com/gogo/protobuf/proto"
+)
+
+// PushEncoder ...
+type PushEncoder interface {
+	Encode(*Push) ([]byte, error)
+	EncodeMessage(*Message) ([]byte, error)
+	EncodePublication(*Publication) ([]byte, error)
+	EncodeJoin(*Join) ([]byte, error)
+	EncodeLeave(*Leave) ([]byte, error)
+	EncodeUnsub(*Unsub) ([]byte, error)
+	EncodeSub(*Sub) ([]byte, error)
+}
+
+// JSONPushEncoder ...
+type JSONPushEncoder struct {
+}
+
+// NewJSONPushEncoder ...
+func NewJSONPushEncoder() *JSONPushEncoder {
+	return &JSONPushEncoder{}
+}
+
+// Encode ...
+func (e *JSONPushEncoder) Encode(message *Push) ([]byte, error) {
+	return json.Marshal(message)
+}
+
+// EncodePublication ...
+func (e *JSONPushEncoder) EncodePublication(message *Publication) ([]byte, error) {
+	return json.Marshal(message)
+}
+
+// EncodeMessage ...
+func (e *JSONPushEncoder) EncodeMessage(message *Message) ([]byte, error) {
+	return json.Marshal(message)
+}
+
+// EncodeJoin ...
+func (e *JSONPushEncoder) EncodeJoin(message *Join) ([]byte, error) {
+	return json.Marshal(message)
+}
+
+// EncodeLeave ...
+func (e *JSONPushEncoder) EncodeLeave(message *Leave) ([]byte, error) {
+	return json.Marshal(message)
+}
+
+// EncodeUnsub ...
+func (e *JSONPushEncoder) EncodeUnsub(message *Unsub) ([]byte, error) {
+	return json.Marshal(message)
+}
+
+// EncodeSub ...
+func (e *JSONPushEncoder) EncodeSub(message *Sub) ([]byte, error) {
+	return json.Marshal(message)
+}
+
+// ProtobufPushEncoder ...
+type ProtobufPushEncoder struct {
+}
+
+// NewProtobufPushEncoder ...
+func NewProtobufPushEncoder() *ProtobufPushEncoder {
+	return &ProtobufPushEncoder{}
+}
+
+// Encode ...
+func (e *ProtobufPushEncoder) Encode(message *Push) ([]byte, error) {
+	return message.Marshal()
+}
+
+// EncodePublication ...
+func (e *ProtobufPushEncoder) EncodePublication(message *Publication) ([]byte, error) {
+	return message.Marshal()
+}
+
+// EncodeMessage ...
+func (e *ProtobufPushEncoder) EncodeMessage(message *Message) ([]byte, error) {
+	return message.Marshal()
+}
+
+// EncodeJoin ...
+func (e *ProtobufPushEncoder) EncodeJoin(message *Join) ([]byte, error) {
+	return message.Marshal()
+}
+
+// EncodeLeave ...
+func (e *ProtobufPushEncoder) EncodeLeave(message *Leave) ([]byte, error) {
+	return message.Marshal()
+}
+
+// EncodeUnsub ...
+func (e *ProtobufPushEncoder) EncodeUnsub(message *Unsub) ([]byte, error) {
+	return message.Marshal()
+}
+
+// EncodeSub ...
+func (e *ProtobufPushEncoder) EncodeSub(message *Sub) ([]byte, error) {
+	return message.Marshal()
+}
+
+// ReplyEncoder ...
+type ReplyEncoder interface {
+	Reset()
+	Encode(*Reply) error
+	Finish() []byte
+}
+
+// JSONReplyEncoder ...
+type JSONReplyEncoder struct {
+	buffer bytes.Buffer
+}
+
+// NewJSONReplyEncoder ...
+func NewJSONReplyEncoder() *JSONReplyEncoder {
+	return &JSONReplyEncoder{}
+}
+
+// Reset ...
+func (e *JSONReplyEncoder) Reset() {
+	e.buffer.Reset()
+}
+
+// Encode ...
+func (e *JSONReplyEncoder) Encode(r *Reply) error {
+	data, err := json.Marshal(r)
+	if err != nil {
+		return err
+	}
+	e.buffer.Write(data)
+	e.buffer.WriteString("\n")
+	return nil
+}
+
+// Finish ...
+func (e *JSONReplyEncoder) Finish() []byte {
+	data := e.buffer.Bytes()
+	dataCopy := make([]byte, len(data))
+	copy(dataCopy, data)
+	return dataCopy
+}
+
+// ProtobufReplyEncoder ...
+type ProtobufReplyEncoder struct {
+	buffer bytes.Buffer
+}
+
+// NewProtobufReplyEncoder ...
+func NewProtobufReplyEncoder() *ProtobufReplyEncoder {
+	return &ProtobufReplyEncoder{}
+}
+
+// Encode ...
+func (e *ProtobufReplyEncoder) Encode(r *Reply) error {
+	replyBytes, err := r.Marshal()
+	if err != nil {
+		return err
+	}
+	bs := make([]byte, 8)
+	n := binary.PutUvarint(bs, uint64(len(replyBytes)))
+	e.buffer.Write(bs[:n])
+	e.buffer.Write(replyBytes)
+	return nil
+}
+
+// Reset ...
+func (e *ProtobufReplyEncoder) Reset() {
+	e.buffer.Reset()
+}
+
+// Finish ...
+func (e *ProtobufReplyEncoder) Finish() []byte {
+	data := e.buffer.Bytes()
+	dataCopy := make([]byte, len(data))
+	copy(dataCopy, data)
+	return dataCopy
+}
+
+// ResultEncoder ...
+type ResultEncoder interface {
+	EncodeConnectResult(*ConnectResult) ([]byte, error)
+	EncodeRefreshResult(*RefreshResult) ([]byte, error)
+	EncodeSubscribeResult(*SubscribeResult) ([]byte, error)
+	EncodeSubRefreshResult(*SubRefreshResult) ([]byte, error)
+	EncodeUnsubscribeResult(*UnsubscribeResult) ([]byte, error)
+	EncodePublishResult(*PublishResult) ([]byte, error)
+	EncodePresenceResult(*PresenceResult) ([]byte, error)
+	EncodePresenceStatsResult(*PresenceStatsResult) ([]byte, error)
+	EncodeHistoryResult(*HistoryResult) ([]byte, error)
+	EncodePingResult(*PingResult) ([]byte, error)
+	EncodeRPCResult(*RPCResult) ([]byte, error)
+}
+
+// JSONResultEncoder ...
+type JSONResultEncoder struct{}
+
+// NewJSONResultEncoder ...
+func NewJSONResultEncoder() *JSONResultEncoder {
+	return &JSONResultEncoder{}
+}
+
+// EncodeConnectResult ...
+func (e *JSONResultEncoder) EncodeConnectResult(res *ConnectResult) ([]byte, error) {
+	return json.Marshal(res)
+}
+
+// EncodeRefreshResult ...
+func (e *JSONResultEncoder) EncodeRefreshResult(res *RefreshResult) ([]byte, error) {
+	return json.Marshal(res)
+}
+
+// EncodeSubscribeResult ...
+func (e *JSONResultEncoder) EncodeSubscribeResult(res *SubscribeResult) ([]byte, error) {
+	return json.Marshal(res)
+}
+
+// EncodeSubRefreshResult ...
+func (e *JSONResultEncoder) EncodeSubRefreshResult(res *SubRefreshResult) ([]byte, error) {
+	return json.Marshal(res)
+}
+
+// EncodeUnsubscribeResult ...
+func (e *JSONResultEncoder) EncodeUnsubscribeResult(res *UnsubscribeResult) ([]byte, error) {
+	return json.Marshal(res)
+}
+
+// EncodePublishResult ...
+func (e *JSONResultEncoder) EncodePublishResult(res *PublishResult) ([]byte, error) {
+	return json.Marshal(res)
+}
+
+// EncodePresenceResult ...
+func (e *JSONResultEncoder) EncodePresenceResult(res *PresenceResult) ([]byte, error) {
+	return json.Marshal(res)
+}
+
+// EncodePresenceStatsResult ...
+func (e *JSONResultEncoder) EncodePresenceStatsResult(res *PresenceStatsResult) ([]byte, error) {
+	return json.Marshal(res)
+}
+
+// EncodeHistoryResult ...
+func (e *JSONResultEncoder) EncodeHistoryResult(res *HistoryResult) ([]byte, error) {
+	return json.Marshal(res)
+}
+
+// EncodePingResult ...
+func (e *JSONResultEncoder) EncodePingResult(res *PingResult) ([]byte, error) {
+	return json.Marshal(res)
+}
+
+// EncodeRPCResult ...
+func (e *JSONResultEncoder) EncodeRPCResult(res *RPCResult) ([]byte, error) {
+	return json.Marshal(res)
+}
+
+// ProtobufResultEncoder ...
+type ProtobufResultEncoder struct{}
+
+// NewProtobufResultEncoder ...
+func NewProtobufResultEncoder() *ProtobufResultEncoder {
+	return &ProtobufResultEncoder{}
+}
+
+// EncodeConnectResult ...
+func (e *ProtobufResultEncoder) EncodeConnectResult(res *ConnectResult) ([]byte, error) {
+	return res.Marshal()
+}
+
+// EncodeRefreshResult ...
+func (e *ProtobufResultEncoder) EncodeRefreshResult(res *RefreshResult) ([]byte, error) {
+	return res.Marshal()
+}
+
+// EncodeSubscribeResult ...
+func (e *ProtobufResultEncoder) EncodeSubscribeResult(res *SubscribeResult) ([]byte, error) {
+	return res.Marshal()
+}
+
+// EncodeSubRefreshResult ...
+func (e *ProtobufResultEncoder) EncodeSubRefreshResult(res *SubRefreshResult) ([]byte, error) {
+	return res.Marshal()
+}
+
+// EncodeUnsubscribeResult ...
+func (e *ProtobufResultEncoder) EncodeUnsubscribeResult(res *UnsubscribeResult) ([]byte, error) {
+	return res.Marshal()
+}
+
+// EncodePublishResult ...
+func (e *ProtobufResultEncoder) EncodePublishResult(res *PublishResult) ([]byte, error) {
+	return res.Marshal()
+}
+
+// EncodePresenceResult ...
+func (e *ProtobufResultEncoder) EncodePresenceResult(res *PresenceResult) ([]byte, error) {
+	return res.Marshal()
+}
+
+// EncodePresenceStatsResult ...
+func (e *ProtobufResultEncoder) EncodePresenceStatsResult(res *PresenceStatsResult) ([]byte, error) {
+	return res.Marshal()
+}
+
+// EncodeHistoryResult ...
+func (e *ProtobufResultEncoder) EncodeHistoryResult(res *HistoryResult) ([]byte, error) {
+	return res.Marshal()
+}
+
+// EncodePingResult ...
+func (e *ProtobufResultEncoder) EncodePingResult(res *PingResult) ([]byte, error) {
+	return res.Marshal()
+}
+
+// EncodeRPCResult ...
+func (e *ProtobufResultEncoder) EncodeRPCResult(res *RPCResult) ([]byte, error) {
+	return res.Marshal()
+}
+
+// CommandEncoder ...
+type CommandEncoder interface {
+	Encode(cmd *Command) ([]byte, error)
+}
+
+// JSONCommandEncoder ...
+type JSONCommandEncoder struct {
+}
+
+// NewJSONCommandEncoder ...
+func NewJSONCommandEncoder() *JSONCommandEncoder {
+	return &JSONCommandEncoder{}
+}
+
+// Encode ...
+func (e *JSONCommandEncoder) Encode(cmd *Command) ([]byte, error) {
+	return json.Marshal(cmd)
+}
+
+// ProtobufCommandEncoder ...
+type ProtobufCommandEncoder struct {
+}
+
+// NewProtobufCommandEncoder ...
+func NewProtobufCommandEncoder() *ProtobufCommandEncoder {
+	return &ProtobufCommandEncoder{}
+}
+
+// Encode ...
+func (e *ProtobufCommandEncoder) Encode(cmd *Command) ([]byte, error) {
+	commandBytes, err := cmd.Marshal()
+	if err != nil {
+		return nil, err
+	}
+	bs := make([]byte, 8)
+	n := binary.PutUvarint(bs, uint64(len(commandBytes)))
+	var buf bytes.Buffer
+	buf.Write(bs[:n])
+	buf.Write(commandBytes)
+	return buf.Bytes(), nil
+}
+
+// ParamsEncoder ...
+type ParamsEncoder interface {
+	Encode(request interface{}) ([]byte, error)
+}
+
+// JSONParamsEncoder ...
+type JSONParamsEncoder struct{}
+
+// NewJSONParamsEncoder ...
+func NewJSONParamsEncoder() *JSONParamsEncoder {
+	return &JSONParamsEncoder{}
+}
+
+// Encode ...
+func (d *JSONParamsEncoder) Encode(r interface{}) ([]byte, error) {
+	return json.Marshal(r)
+}
+
+// ProtobufParamsEncoder ...
+type ProtobufParamsEncoder struct{}
+
+// NewProtobufParamsEncoder ...
+func NewProtobufParamsEncoder() *ProtobufParamsEncoder {
+	return &ProtobufParamsEncoder{}
+}
+
+// Encode ...
+func (d *ProtobufParamsEncoder) Encode(r interface{}) ([]byte, error) {
+	m, ok := r.(proto.Marshaler)
+	if !ok {
+		return nil, fmt.Errorf("can not marshal type %T to Protobuf", r)
+	}
+	return m.Marshal()
+}
diff --git a/vendor/github.com/centrifugal/protocol/encoding.go b/vendor/github.com/centrifugal/protocol/encoding.go
new file mode 100644
index 0000000..6290ed4
--- /dev/null
+++ b/vendor/github.com/centrifugal/protocol/encoding.go
@@ -0,0 +1,11 @@
+package protocol
+
+// EncodingType determines connection payload encoding type.
+type EncodingType string
+
+const (
+	// EncodingTypeJSON means JSON payload.
+	EncodingTypeJSON EncodingType = "json"
+	// EncodingTypeBinary means binary payload.
+	EncodingTypeBinary EncodingType = "binary"
+)
diff --git a/vendor/github.com/centrifugal/protocol/error.go b/vendor/github.com/centrifugal/protocol/error.go
new file mode 100644
index 0000000..1950316
--- /dev/null
+++ b/vendor/github.com/centrifugal/protocol/error.go
@@ -0,0 +1,9 @@
+package protocol
+
+import (
+	"fmt"
+)
+
+func (e Error) Error() string {
+	return fmt.Sprintf("%d: %s", e.Code, e.Message)
+}
diff --git a/vendor/github.com/centrifugal/protocol/go.mod b/vendor/github.com/centrifugal/protocol/go.mod
new file mode 100644
index 0000000..219f6de
--- /dev/null
+++ b/vendor/github.com/centrifugal/protocol/go.mod
@@ -0,0 +1,5 @@
+module github.com/centrifugal/protocol
+
+go 1.13
+
+require github.com/gogo/protobuf v1.3.1
diff --git a/vendor/github.com/centrifugal/protocol/go.sum b/vendor/github.com/centrifugal/protocol/go.sum
new file mode 100644
index 0000000..92a3c96
--- /dev/null
+++ b/vendor/github.com/centrifugal/protocol/go.sum
@@ -0,0 +1,5 @@
+github.com/gogo/protobuf v1.3.1 h1:DqDEcV5aeaTmdFBePNpYsp3FlcVH/2ISVVM9Qf8PSls=
+github.com/gogo/protobuf v1.3.1/go.mod h1:SlYgWuQ5SjCEi6WLHjHCa1yvBfUnHcTbrrZtXPKa29o=
+github.com/kisielk/errcheck v1.2.0/go.mod h1:/BMXB+zMLi60iA8Vv6Ksmxu/1UDYcXs4uQLJ+jE2L00=
+github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
+golang.org/x/tools v0.0.0-20181030221726-6c7e314b6563/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
diff --git a/vendor/github.com/centrifugal/protocol/raw.go b/vendor/github.com/centrifugal/protocol/raw.go
new file mode 100644
index 0000000..a257170
--- /dev/null
+++ b/vendor/github.com/centrifugal/protocol/raw.go
@@ -0,0 +1,93 @@
+package protocol
+
+import (
+	"bytes"
+	"errors"
+)
+
+// Raw type used by Centrifuge protocol as a type for fields in structs which
+// value we want to stay untouched. For example custom application specific JSON
+// payload data in published message. This is very similar to json.RawMessage
+// type but have some extra methods to fit gogo/protobuf custom type interface.
+type Raw []byte
+
+// Marshal encodes Raw to slice of bytes. Exists to fit gogo/protobuf custom
+// type interface.
+func (r Raw) Marshal() ([]byte, error) {
+	if len(r) == 0 {
+		return nil, nil
+	}
+	return r, nil
+}
+
+// MarshalTo exists to fit gogo/protobuf custom type interface.
+func (r Raw) MarshalTo(data []byte) (n int, err error) {
+	if len(r) == 0 {
+		return 0, nil
+	}
+	copy(data, r)
+	return len(r), nil
+}
+
+// Unmarshal exists to fit gogo/protobuf custom type interface.
+func (r *Raw) Unmarshal(data []byte) error {
+	if len(data) == 0 {
+		r = nil
+		return nil
+	}
+	id := Raw(make([]byte, len(data)))
+	copy(id, data)
+	*r = id
+	return nil
+}
+
+// Size exists to fit gogo/protobuf custom type interface.
+func (r *Raw) Size() int {
+	if r == nil {
+		return 0
+	}
+	return len(*r)
+}
+
+// MarshalJSON returns *r as the JSON encoding of r.
+func (r Raw) MarshalJSON() ([]byte, error) {
+	if r == nil {
+		return []byte("null"), nil
+	}
+	return r, nil
+}
+
+// UnmarshalJSON sets *r to a copy of data.
+func (r *Raw) UnmarshalJSON(data []byte) error {
+	if r == nil {
+		return errors.New("unmarshal Raw: UnmarshalJSON on nil pointer")
+	}
+	*r = append((*r)[0:0], data...)
+	return nil
+}
+
+// Equal exists to fit gogo/protobuf custom type interface.
+func (r Raw) Equal(other Raw) bool {
+	return bytes.Equal(r[0:], other[0:])
+}
+
+// Compare exists to fit gogo/protobuf custom type interface.
+func (r Raw) Compare(other Raw) int {
+	return bytes.Compare(r[0:], other[0:])
+}
+
+type intn interface {
+	Intn(n int) int
+}
+
+// NewPopulatedRaw required for gogoprotobuf custom type.
+func NewPopulatedRaw(r intn) *Raw {
+	v1 := r.Intn(100)
+	data := make([]byte, v1)
+	for i := 0; i < v1; i++ {
+		data[i] = byte('a')
+	}
+	d := `{"key":"` + string(data) + `"}`
+	raw := Raw(d)
+	return &raw
+}
diff --git a/vendor/github.com/centrifugal/protocol/readme.md b/vendor/github.com/centrifugal/protocol/readme.md
new file mode 100644
index 0000000..c0f8f9a
--- /dev/null
+++ b/vendor/github.com/centrifugal/protocol/readme.md
@@ -0,0 +1,12 @@
+Centrifuge client protocol definitions. [Docs on go.dev](https://pkg.go.dev/github.com/centrifugal/protocol).
+
+To make changes in proto first install `protoc`.
+
+Make required changes in `client.template` file. 
+
+Then run:
+
+```
+make install
+make
+```
diff --git a/vendor/github.com/centrifugal/protocol/type.go b/vendor/github.com/centrifugal/protocol/type.go
new file mode 100644
index 0000000..fb4b875
--- /dev/null
+++ b/vendor/github.com/centrifugal/protocol/type.go
@@ -0,0 +1,96 @@
+package protocol
+
+import "sync"
+
+// Type determines connection protocol type.
+type Type string
+
+const (
+	// TypeJSON means JSON protocol - in this case data encoded in
+	// JSON-streaming format.
+	TypeJSON Type = "json"
+	// TypeProtobuf means protobuf protocol - in this case data encoded
+	// as length-delimited (varint) protobuf messages.
+	TypeProtobuf Type = "protobuf"
+)
+
+// GetPushEncoder ...
+func GetPushEncoder(protoType Type) PushEncoder {
+	if protoType == TypeJSON {
+		return NewJSONPushEncoder()
+	}
+	return NewProtobufPushEncoder()
+}
+
+var (
+	jsonReplyEncoderPool     sync.Pool
+	protobufReplyEncoderPool sync.Pool
+)
+
+// GetReplyEncoder ...
+func GetReplyEncoder(protoType Type) ReplyEncoder {
+	if protoType == TypeJSON {
+		e := jsonReplyEncoderPool.Get()
+		if e == nil {
+			return NewJSONReplyEncoder()
+		}
+		protoTypeoder := e.(ReplyEncoder)
+		protoTypeoder.Reset()
+		return protoTypeoder
+	}
+	e := protobufReplyEncoderPool.Get()
+	if e == nil {
+		return NewProtobufReplyEncoder()
+	}
+	protoTypeoder := e.(ReplyEncoder)
+	protoTypeoder.Reset()
+	return protoTypeoder
+}
+
+// PutReplyEncoder ...
+func PutReplyEncoder(protoType Type, e ReplyEncoder) {
+	if protoType == TypeJSON {
+		jsonReplyEncoderPool.Put(e)
+		return
+	}
+	protobufReplyEncoderPool.Put(e)
+}
+
+// GetCommandDecoder ...
+func GetCommandDecoder(protoType Type, data []byte) CommandDecoder {
+	if protoType == TypeJSON {
+		return NewJSONCommandDecoder(data)
+	}
+	return NewProtobufCommandDecoder(data)
+}
+
+// PutCommandDecoder ...
+func PutCommandDecoder(protoType Type, e CommandDecoder) {
+	return
+}
+
+// GetResultEncoder ...
+func GetResultEncoder(protoType Type) ResultEncoder {
+	if protoType == TypeJSON {
+		return NewJSONResultEncoder()
+	}
+	return NewProtobufResultEncoder()
+}
+
+// PutResultEncoder ...
+func PutResultEncoder(protoType Type, e ReplyEncoder) {
+	return
+}
+
+// GetParamsDecoder ...
+func GetParamsDecoder(protoType Type) ParamsDecoder {
+	if protoType == TypeJSON {
+		return NewJSONParamsDecoder()
+	}
+	return NewProtobufParamsDecoder()
+}
+
+// PutParamsDecoder ...
+func PutParamsDecoder(protoType Type, e ParamsDecoder) {
+	return
+}
-- 
2.30.1

